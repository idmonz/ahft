Langlands-Operadic Möbius Vortex (LOMV)

🛸 LOMV
Langlands-Operadic Möbius Vortex (LOMV)
Where Pure Mathematics Meets Market Reality


A Revolutionary Synthesis of Number Theory, Category Theory, and Market Dynamics


🎓 THEORETICAL FOUNDATION


The Langlands-Operadic Möbius Vortex represents a groundbreaking fusion of three profound mathematical frameworks that have never before been combined for market analysis:


The Langlands Program: Harmonic Analysis in Markets


Developed by Robert Langlands (Fields Medal recipient), the Langlands Program creates bridges between number theory, algebraic geometry, and harmonic analysis. In our indicator:


L-Function Implementation:
- Utilizes the Möbius function μ(n) for weighted price analysis
- Applies Riemann zeta function convergence principles
- Calculates quantum harmonic resonance between -2 and +2
- Measures deep mathematical patterns invisible to traditional analysis


The L-Function core calculation employs:
L_sum = Σ(return_val × μ(n) × n^(-s))


Where s is the critical strip parameter (0.5-2.5), controlling mathematical precision and signal smoothness.


Operadic Composition Theory: Multi-Strategy Democracy


Category theory and operads provide the mathematical framework for composing multiple trading strategies into a unified signal. This isn't simple averaging - it's mathematical composition using:


Strategy Composition Arity (2-5 strategies):
- Momentum analysis via RSI transformation
- Mean reversion through Bollinger Band mathematics
- Order Flow Polarity Index (revolutionary T3-smoothed volume analysis)
- Trend detection using Directional Movement
- Higher timeframe momentum confirmation


Agreement Threshold System: Democratic voting where strategies must reach consensus before signal generation. This prevents false signals during market uncertainty.


Möbius Function: Number Theory in Action


The Möbius function μ(n) forms the mathematical backbone:
- μ(n) = 1 if n is a square-free positive integer with even number of prime factors
- μ(n) = -1 if n is a square-free positive integer with odd number of prime factors
- μ(n) = 0 if n has a squared prime factor


This creates oscillating weights that reveal hidden market periodicities and harmonic structures.


🔧 COMPREHENSIVE INPUT SYSTEM


Langlands Program Parameters


Modular Level N (5-50, default 30):
Primary lookback for quantum harmonic analysis. Optimized by timeframe:
- Scalping (1-5min): 15-25
- Day Trading (15min-1H): 25-35
- Swing Trading (4H-1D): 35-50
- Asset-specific: Crypto 15-25, Stocks 30-40, Forex 35-45


L-Function Critical Strip (0.5-2.5, default 1.5):
Controls Riemann zeta convergence precision:
- Higher values: More stable, smoother signals
- Lower values: More reactive, catches quick moves
- High frequency: 0.8-1.2, Medium: 1.3-1.7, Low: 1.8-2.3


Frobenius Trace Period (5-50, default 21):
Galois representation lookback for price-volume correlation:
- Measures harmonic relationships in market flows
- Scalping: 8-15, Day Trading: 18-25, Swing: 25-40


HTF Multi-Scale Analysis:
Higher timeframe context prevents trading against major trends:
- Provides market bias and filters signals
- Improves win rates by 15-25% through trend alignment


Operadic Composition Parameters


Strategy Composition Arity (2-5, default 4):
Number of algorithms composed for final signal:
- Conservative: 4-5 strategies (higher confidence)
- Moderate: 3-4 strategies (balanced approach)
- Aggressive: 2-3 strategies (more frequent signals)


Category Agreement Threshold (2-5, default 3):
Democratic voting minimum for signal generation:
- Higher agreement: Fewer but higher quality signals
- Lower agreement: More signals, potential false positives


Swiss-Cheese Mixing (0.1-0.5, default 0.382):
Golden ratio φ⁻¹ based blending of trend factors:
- 0.382 is φ⁻¹, optimal for natural market fractals
- Higher values: Stronger trend following
- Lower values: More contrarian signals


OFPI Configuration:
- OFPI Length (5-30, default 14): Order Flow calculation period
- T3 Smoothing (3-10, default 5): Advanced exponential smoothing
- T3 Volume Factor (0.5-1.0, default 0.7): Smoothing aggressiveness control


Unified Scoring System


Component Weights (sum ≈ 1.0):
- L-Function Weight (0.1-0.5, default 0.3): Mathematical harmony emphasis
- Galois Rank Weight (0.1-0.5, default 0.2): Market structure complexity
- Operadic Weight (0.1-0.5, default 0.3): Multi-strategy consensus
- Correspondence Weight (0.1-0.5, default 0.2): Theory-practice alignment


Signal Threshold (0.5-10.0, default 5.0):
Quality filter producing:
- 8.0+: EXCEPTIONAL signals only
- 6.0-7.9: STRONG signals
- 4.0-5.9: MODERATE signals
- 2.0-3.9: WEAK signals


🎨 ADVANCED VISUAL SYSTEM


Multi-Dimensional Quantum Aura Bands
Five-layer resonance field showing market energy:
- Colors: Theme-matched gradients (Quantum purple, Holographic cyan, etc.)
- Expansion: Dynamic based on score intensity and volatility
- Function: Multi-timeframe support/resistance zones


Morphism Flow Portals
Category theory visualization showing market topology:
- Green/Cyan Portals: Bullish mathematical flow
- Red/Orange Portals: Bearish mathematical flow
- Size/Intensity: Proportional to signal strength
- Recursion Depth (1-8): Nested patterns for flow evolution


Fractal Grid System
Dynamic support/resistance with projected L-Scores:
- Multiple Timeframes: 10, 20, 30, 40, 50-period highs/lows
- Smart Spacing: Prevents level overlap using ATR-based minimum distance
- Projections: Estimated signal scores when price reaches levels
- Usage: Precise entry/exit timing with mathematical confirmation


Wick Pressure Analysis
Rejection level prediction using candle mathematics:
- Upper Wicks: Selling pressure zones (purple/red lines)
- Lower Wicks: Buying pressure zones (purple/green lines)
- Glow Intensity (1-8): Visual emphasis and line reach
- Application: Confluence with fractal grid creates high-probability zones


Regime Intensity Heatmap
Background coloring showing market energy:
- Black/Dark: Low activity, range-bound markets
- Purple Glow: Building momentum and trend development
- Bright Purple: High activity, strong directional moves
- Calculation: Combines trend, momentum, volatility, and score intensity


Six Professional Themes
- Quantum: Purple/violet for general trading and mathematical focus
- Holographic: Cyan/magenta optimized for cryptocurrency markets
- Crystalline: Blue/turquoise for conservative, stability-focused trading
- Plasma: Gold/magenta for high-energy volatility trading
- Cosmic Neon: Bright neon colors for maximum visibility and aggressive trading


📊 INSTITUTIONAL-GRADE DASHBOARD


Unified AI Score Section
- Total Score (-10 to +10): Primary decision metric
- >5: Strong bullish signals
- <-5: Strong bearish signals
- Quality ratings: EXCEPTIONAL > STRONG > MODERATE > WEAK
- Component Analysis: Individual L-Function, Galois, Operadic, and Correspondence contributions


Order Flow Analysis
Revolutionary OFPI integration:
- OFPI Value (-100% to +100%): Real buying vs selling pressure
- Visual Gauge: Horizontal bar chart showing flow intensity
- Momentum Status: SHIFTING, ACCELERATING, STRONG, MODERATE, or WEAK
- Trading Application: Flow shifts often precede major moves


Signal Performance Tracking
- Win Rate Monitoring: Real-time success percentage with emoji indicators
- Signal Count: Total signals generated for frequency analysis
- Current Position: LONG, SHORT, or NONE with P&L tracking
- Volatility Regime: HIGH, MEDIUM, or LOW classification


Market Structure Analysis
- Möbius Field Strength: Mathematical field oscillation intensity
- CHAOTIC: High complexity, use wider stops
- STRONG: Active field, normal position sizing
- MODERATE: Balanced conditions
- WEAK: Low activity, consider smaller positions
- HTF Trend: Higher timeframe bias (BULL/BEAR/NEUTRAL)
- Strategy Agreement: Multi-algorithm consensus level


Position Management
When in trades, displays:
- Entry Price: Original signal price
- Current P&L: Real-time percentage with risk level assessment
- Duration: Bars in trade for timing analysis
- Risk Level: HIGH/MEDIUM/LOW based on current exposure


🚀 SIGNAL GENERATION LOGIC


Balanced Long/Short Architecture
The indicator generates signals through multiple convergent pathways:


Long Entry Conditions:
- Score threshold breach with algorithmic agreement
- Strong bullish order flow (OFPI > 0.15) with positive composite signal
- Bullish pattern recognition with mathematical confirmation
- HTF trend alignment with momentum shifting
- Extreme bullish OFPI (>0.3) with any positive score


Short Entry Conditions:
- Score threshold breach with bearish agreement
- Strong bearish order flow (OFPI < -0.15) with negative composite signal
- Bearish pattern recognition with mathematical confirmation
- HTF trend alignment with momentum shifting
- Extreme bearish OFPI (<-0.3) with any negative score


Exit Logic:
- Score deterioration below continuation threshold
- Signal quality degradation
- Opposing order flow acceleration
- 10-bar minimum between signals prevents overtrading


⚙️ OPTIMIZATION GUIDELINES


Asset-Specific Settings


Cryptocurrency Trading:
- Modular Level: 15-25 (capture volatility)
- L-Function Precision: 0.8-1.3 (reactive to price swings)
- OFPI Length: 10-20 (fast correlation shifts)
- Cascade Levels: 5-7, Theme: Holographic


Stock Index Trading:
- Modular Level: 25-35 (balanced trending)
- L-Function Precision: 1.5-1.8 (stable patterns)
- OFPI Length: 14-20 (standard correlation)
- Cascade Levels: 4-5, Theme: Quantum


Forex Trading:
- Modular Level: 35-45 (smooth trends)
- L-Function Precision: 1.6-2.1 (high smoothing)
- OFPI Length: 18-25 (disable volume amplification)
- Cascade Levels: 3-4, Theme: Crystalline


Timeframe Optimization


Scalping (1-5 minute charts):
- Reduce all lookback parameters by 30-40%
- Increase L-Function precision for noise reduction
- Enable all visual elements for maximum information
- Use Small dashboard to save screen space


Day Trading (15 minute - 1 hour):
- Use default parameters as starting point
- Adjust based on market volatility
- Normal dashboard provides optimal information density
- Focus on OFPI momentum shifts for entries


Swing Trading (4 hour - Daily):
- Increase lookback parameters by 30-50%
- Higher L-Function precision for stability
- Large dashboard for comprehensive analysis
- Emphasize HTF trend alignment


🏆 ADVANCED TRADING STRATEGIES


The Mathematical Confluence Method
1. Wait for Fractal Grid level approach
2. Confirm with projected L-Score > threshold
3. Verify OFPI alignment with direction
4. Enter on portal signal with quality ≥ STRONG
5. Exit on score deterioration or opposing flow


The Regime Trading System
1. Monitor Aether Flow background intensity
2. Trade aggressively during bright purple periods
3. Reduce position size during dark periods
4. Use Möbius Field strength for stop placement
5. Align with HTF trend for maximum probability


The OFPI Momentum Strategy
1. Watch for momentum shifting detection
2. Confirm with accelerating flow in direction
3. Enter on immediate portal signal
4. Scale out at Fibonacci levels
5. Exit on flow deceleration or reversal


⚠️ RISK MANAGEMENT INTEGRATION


Mathematical Position Sizing
- Use Galois Rank for volatility-adjusted sizing
- Möbius Field strength determines stop width
- Fractal Dimension guides maximum exposure
- OFPI momentum affects entry timing


Signal Quality Filtering
- Trade only STRONG or EXCEPTIONAL quality signals
- Increase position size with higher agreement levels
- Reduce risk during CHAOTIC Möbius field periods
- Respect HTF trend alignment for directional bias


🔬 DEVELOPMENT JOURNEY


Creating the LOMV was an extraordinary mathematical undertaking that pushed the boundaries of what's possible in technical analysis. This indicator almost didn't happen. The theoretical complexity nearly proved insurmountable.


The Mathematical Challenge
Implementing the Langlands Program required deep research into:
- Number theory and the Möbius function
- Riemann zeta function convergence properties
- L-function analytical continuation
- Galois representations in finite fields


The mathematical literature spans decades of pure mathematics research, requiring translation from abstract theory to practical market application.


The Computational Complexity
Operadic composition theory demanded:
- Category theory implementation in Pine Script
- Multi-dimensional array management for strategy composition
- Real-time democratic voting algorithms
- Performance optimization for complex calculations


The Integration Breakthrough
Bringing together three disparate mathematical frameworks required:
- Novel approaches to signal weighting and combination
- Revolutionary Order Flow Polarity Index development
- Advanced T3 smoothing implementation
- Balanced signal generation preventing directional bias


Months of intensive research culminated in breakthrough moments when the mathematics finally aligned with market reality. The result is an indicator that reveals market structure invisible to conventional analysis while maintaining practical trading utility.


🎯 PRACTICAL IMPLEMENTATION


Getting Started
1. Apply indicator with default settings
2. Select appropriate theme for your markets
3. Observe dashboard metrics during different market conditions
4. Practice signal identification without trading
5. Gradually adjust parameters based on observations


Signal Confirmation Process
- Never trade on score alone - verify quality rating
- Confirm OFPI alignment with intended direction
- Check fractal grid level proximity for timing
- Ensure Möbius field strength supports position size
- Validate against HTF trend for bias confirmation


Performance Monitoring
- Track win rate in dashboard for strategy assessment
- Monitor component contributions for optimization
- Adjust threshold based on desired signal frequency
- Document performance across different market regimes


🌟 UNIQUE INNOVATIONS


1. First Integration of Langlands Program mathematics with practical trading
2. Revolutionary OFPI with T3 smoothing and momentum detection
3. Operadic Composition using category theory for signal democracy
4. Dynamic Fractal Grid with projected L-Score calculations
5. Multi-Dimensional Visualization through morphism flow portals
6. Regime-Adaptive Background showing market energy intensity
7. Balanced Signal Generation preventing directional bias
8. Professional Dashboard with institutional-grade metrics


📚 EDUCATIONAL VALUE


The LOMV serves as both a practical trading tool and an educational gateway to advanced mathematics. Traders gain exposure to:
- Pure mathematics applications in markets
- Category theory and operadic composition
- Number theory through Möbius function implementation
- Harmonic analysis via L-function calculations
- Advanced signal processing through T3 smoothing


⚖️ RESPONSIBLE USAGE


This indicator represents advanced mathematical research applied to market analysis. While the underlying mathematics are rigorously implemented, markets remain inherently unpredictable.


Key Principles:
- Use as part of comprehensive trading strategy
- Implement proper risk management at all times
- Backtest thoroughly before live implementation
- Understand that past performance does not guarantee future results
- Never risk more than you can afford to lose


The mathematics reveal deep market structure, but successful trading requires discipline, patience, and sound risk management beyond any indicator.


🔮 CONCLUSION


The Langlands-Operadic Möbius Vortex represents a quantum leap forward in technical analysis, bringing PhD-level pure mathematics to practical trading while maintaining visual elegance and usability.


From the harmonic analysis of the Langlands Program to the democratic composition of operadic theory, from the number-theoretic precision of the Möbius function to the revolutionary Order Flow Polarity Index, every component works in mathematical harmony to reveal the hidden order within market chaos.


This is more than an indicator - it's a mathematical lens that transforms how you see and understand market structure.


Trade with mathematical precision. Trade with the LOMV.
*"Mathematics is the language with which God has written the universe." - Galileo Galilei*


*In markets, as in nature, profound mathematical beauty underlies apparent chaos. The LOMV reveals this hidden order.*
— Dskyz, Trade with insight. Trade with anticipation.

//@version=5
indicator("Langlands-Operadic Möbius Vortex (LOMV)", shorttitle="🛸 LOMV", overlay=true, max_lines_count=500, max_labels_count=500, max_boxes_count=500)

///==============================================================================
// 📚 USER GUIDE & THEORY EXPLANATIONS
//==============================================================================
// 🎯 DASHBOARD LEGEND:
// • 🛸 UNIFIED AI SCORE: -10 to +10 scale, >5 = strong bullish, <-5 = strong bearish
// • 🔮 L-Function: Quantum price resonance (-2 to +2), measures harmonic convergence
// • ⚡ Galois Rank: Market structure complexity (0-1), higher = more volatile/trending
// • 🌀 Operadic: Multi-strategy consensus (-1 to +1), algorithmic agreement strength  
// • 🔗 Correspondence: Theory alignment quality (0-1), higher = more reliable signals
// • 📊 OFPI: Order Flow Polarity (-100% to +100%), real buying/selling pressure
// • 🎭 Signal Quality: EXCEPTIONAL > STRONG > MODERATE > WEAK
//
// 🎨 VISUAL ELEMENTS:
// • 🌈 Quantum Aura Bands: Multi-dimensional support/resistance zones
// • 🌀 Portal Effects: Directional flow visualization (green=bullish, red=bearish)
// • ⚡ Wick Pressure Lines: Rejection level predictions
// • 📐 Fractal Grid: Key price levels with projected L-Scores
// • 🌌 Aether Flow: Background intensity showing market regime strength
//
// 🧠 TRADING PSYCHOLOGY:
// • Multiple timeframe confluence increases signal reliability
// • OFPI momentum shifts often precede major moves
// • Exceptional quality signals have highest win rates
// • Use fractal grid for precise entry/exit timing
// • Combine visual themes with market type (Quantum=general, Holographic=crypto, etc.)

//==============================================================================
// 🔮 LANGLANDS PROGRAM PARAMETERS
//==============================================================================
group_langlands = "🔮 Langlands Program Parameters"

modular_level = input.int(30, "📊 Modular Level N (L-Function Lookback)", minval=5, maxval=50, group=group_langlands, 
  tooltip="🎯 WHAT IT IS: Primary lookback period for quantum harmonic analysis using Möbius function\n\n" +
  "⚡ HOW IT WORKS: Calculates weighted price returns using number theory (Möbius μ function)\n\n" +
  "📈 POSITIVE ADJUSTMENT: Longer lookback = smoother signals, less noise, slower reaction\n" +
  "📉 NEGATIVE ADJUSTMENT: Shorter lookback = faster signals, more sensitive, higher noise\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• 1min-5min: Use 15-25 for scalping\n" +
  "• 15min-1H: Use 25-35 for day trading\n" +
  "• 4H-1D: Use 35-50 for swing trading\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• Stocks: 30-40 (stable)\n" +
  "• Indices: 25-35 (trending)\n" +
  "• Crypto: 15-25 (volatile)\n" +
  "• Forex: 35-45 (smooth)")

l_function_precision = input.float(1.5, "🔬 L-Function Critical Strip (s)", minval=0.5, maxval=2.5, step=0.1, group=group_langlands,
  tooltip="🎯 WHAT IT IS: Mathematical precision parameter for Riemann zeta function convergence\n\n" +
  "⚡ HOW IT WORKS: Controls weight decay in harmonic series (1/n^s), affects signal smoothness\n\n" +
  "📈 HIGHER VALUES (1.8-2.5): More stable, less reactive, smoother curves\n" +
  "📉 LOWER VALUES (0.5-1.2): More reactive, noisier, catches quick moves\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• High Frequency (1min-5min): 0.8-1.2\n" +
  "• Medium Frequency (15min-1H): 1.3-1.7\n" +
  "• Low Frequency (4H+): 1.8-2.3\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• Stocks: 1.5-1.8 (balanced)\n" +
  "• Crypto: 0.8-1.3 (catch volatility)\n" +
  "• Forex: 1.6-2.1 (smooth trends)\n" +
  "• Commodities: 1.4-1.9 (medium)")

frobenius_lookback = input.int(21, "🔄 Frobenius Trace Period", minval=5, maxval=50, group=group_langlands,
  tooltip="🎯 WHAT IT IS: Lookback for price-volume correlation analysis (Galois representation)\n\n" +
  "⚡ HOW IT WORKS: Measures harmonic relationship between price and volume flows\n\n" +
  "📈 LONGER PERIODS: More stable correlations, slower adaptation\n" +
  "📉 SHORTER PERIODS: Faster correlation changes, more sensitive\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping: 8-15 periods\n" +
  "• Day Trading: 18-25 periods\n" +
  "• Swing Trading: 25-40 periods\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• High Volume Stocks: 15-25\n" +
  "• Low Volume Stocks: 25-35\n" +
  "• Crypto: 10-20 (fast correlation shifts)\n" +
  "• Indices: 20-30 (stable correlations)")

htf_tf = input.timeframe("60", "⏰ HTF for Multi-Scale Analysis", group=group_langlands,
  tooltip="🎯 WHAT IT IS: Higher timeframe for trend confirmation and bias\n\n" +
  "⚡ HOW IT WORKS: Provides market context and filters signals against major trends\n\n" +
  "📊 TIMEFRAME MULTIPLIERS:\n" +
  "• Chart TF 1min → HTF 5min-15min\n" +
  "• Chart TF 5min → HTF 30min-1H\n" +
  "• Chart TF 15min → HTF 1H-4H\n" +
  "• Chart TF 1H → HTF 4H-1D\n\n" +
  "🎯 TRADING STYLES:\n" +
  "• Scalping: Use 3-5x multiplier\n" +
  "• Day Trading: Use 4-6x multiplier\n" +
  "• Swing Trading: Use 6-12x multiplier\n\n" +
  "💡 PRO TIP: Higher timeframe bias improves win rate by 15-25%")

//==============================================================================
// ∞ OPERADIC COMPOSITION PARAMETERS  
//==============================================================================
group_operadic = "∞ Operadic Composition Parameters"

composition_arity = input.int(4, "🎭 Strategy Composition Arity", minval=2, maxval=5, group=group_operadic,
  tooltip="🎯 WHAT IT IS: Number of trading strategies combined for final signal\n\n" +
  "⚡ HOW IT WORKS: Uses category theory to compose multiple algorithms\n\n" +
  "📈 MORE STRATEGIES (4-5): Higher confidence, fewer but stronger signals\n" +
  "📉 FEWER STRATEGIES (2-3): More signals, potentially less reliable\n\n" +
  "🎯 OPTIMAL SETTINGS:\n" +
  "• Conservative Trading: 4-5 strategies\n" +
  "• Moderate Trading: 3-4 strategies  \n" +
  "• Aggressive Trading: 2-3 strategies\n\n" +
  "🏦 MARKET CONDITIONS:\n" +
  "• Trending Markets: 3-4 (balance speed/accuracy)\n" +
  "• Choppy Markets: 4-5 (need more confirmation)\n" +
  "• High Volatility: 4-5 (filter noise)")

agreement_required = input.int(3, "🤝 Category Agreement Threshold", minval=2, maxval=5, group=group_operadic,
  tooltip="🎯 WHAT IT IS: Minimum number of strategies that must agree for signal\n\n" +
  "⚡ HOW IT WORKS: Democratic voting system among composed strategies\n\n" +
  "📈 HIGHER AGREEMENT: Fewer but higher quality signals\n" +
  "📉 LOWER AGREEMENT: More signals but potentially more false positives\n\n" +
  "🎯 RECOMMENDED RATIOS:\n" +
  "• Conservative: Agreement = Arity (100% consensus)\n" +
  "• Moderate: Agreement = Arity - 1 (majority++)\n" +
  "• Aggressive: Agreement = 50-60% of Arity\n\n" +
  "💡 OPTIMAL COMBINATIONS:\n" +
  "• Arity 5, Agreement 4: Ultra-high quality\n" +
  "• Arity 4, Agreement 3: Balanced approach\n" +
  "• Arity 3, Agreement 2: More frequent signals")

swiss_cheese_weight = input.float(0.382, "🧀 Swiss-Cheese Mixing (φ⁻¹)", minval=0.1, maxval=0.5, step=0.05, group=group_operadic,
  tooltip="🎯 WHAT IT IS: Golden ratio based blending of trend alignment factors\n\n" +
  "⚡ HOW IT WORKS: Applies φ⁻¹ (inverse golden ratio) for natural market harmonics\n\n" +
  "📈 HIGHER VALUES (0.4-0.5): Stronger trend following, less contrarian\n" +
  "📉 LOWER VALUES (0.1-0.25): More contrarian signals, less trend bias\n\n" +
  "🎯 MARKET PERSONALITY:\n" +
  "• Strong Trending: 0.35-0.45\n" +
  "• Range Bound: 0.15-0.25  \n" +
  "• Mixed Conditions: 0.30-0.40\n\n" +
  "🔬 MATHEMATICAL NOTE: 0.382 is φ⁻¹, optimal for natural market fractals\n" +
  "💡 PRO TIP: Fibonacci levels work because markets follow golden ratio dynamics")

ofpi_length = input.int(14, "📊 OFPI Lookback Length", minval=5, maxval=30, group=group_operadic,
  tooltip="🎯 WHAT IT IS: Order Flow Polarity Index calculation period\n\n" +
  "⚡ HOW IT WORKS: Measures real buying vs selling pressure using volume analysis\n\n" +
  "📈 LONGER PERIODS: Smoother OFPI, less noise, slower adaptation\n" +
  "📉 SHORTER PERIODS: More sensitive to flow changes, faster signals\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping (1-5min): 8-12\n" +
  "• Intraday (15min-1H): 12-18\n" +
  "• Swing (4H+): 18-25\n\n" +
  "🏦 VOLUME CHARACTERISTICS:\n" +
  "• High Volume Assets: 10-16\n" +
  "• Medium Volume: 14-20\n" +
  "• Low Volume: 18-25")

ofpi_t3_length = input.int(5, "⚡ OFPI T3 Smoothing", minval=3, maxval=10, group=group_operadic,
  tooltip="🎯 WHAT IT IS: T3 (Tillson) smoothing for OFPI noise reduction\n\n" +
  "⚡ HOW IT WORKS: Advanced exponential smoothing with minimal lag\n\n" +
  "📈 HIGHER VALUES: Smoother OFPI, less whipsaws\n" +
  "📉 LOWER VALUES: More responsive, catches quick shifts\n\n" +
  "🎯 OPTIMAL SETTINGS:\n" +
  "• Noisy Markets: 6-8\n" +
  "• Clean Trends: 3-5\n" +
  "• Mixed Conditions: 4-6\n\n" +
  "💡 T3 ADVANTAGE: Superior to regular EMA for reducing lag while maintaining smoothness")

ofpi_t3_vfactor = input.float(0.7, "🎛️ OFPI T3 Volume Factor", minval=0.5, maxval=1.0, step=0.1, group=group_operadic,
  tooltip="🎯 WHAT IT IS: T3 algorithm volume factor for smoothing aggressiveness\n\n" +
  "⚡ HOW IT WORKS: Controls balance between responsiveness and smoothness\n\n" +
  "📈 HIGHER VALUES (0.8-1.0): Maximum smoothness, minimal noise\n" +
  "📉 LOWER VALUES (0.5-0.7): More responsive, faster reaction\n\n" +
  "🎯 MARKET ADAPTATION:\n" +
  "• Volatile Markets: 0.8-0.9 (need smoothing)\n" +
  "• Stable Markets: 0.6-0.7 (want responsiveness)\n" +
  "• Crypto: 0.7-0.8 (balance volatility)\n\n" +
  "🔬 TECHNICAL: 0.7 provides optimal lag vs noise reduction ratio")

//==============================================================================
// 🎯 UNIFIED SCORING SYSTEM
//==============================================================================
group_scoring = "🎯 Unified Scoring System"

l_function_weight = input.float(0.3, "🔮 L-Function Weight", minval=0.1, maxval=0.5, step=0.05, group=group_scoring,
  tooltip="🎯 WHAT IT IS: Importance weight for quantum harmonic analysis in final score\n\n" +
  "⚡ HOW IT WORKS: Mathematical beauty score from number theory patterns\n\n" +
  "📈 HIGHER WEIGHT: More emphasis on mathematical harmony and cycles\n" +
  "📉 LOWER WEIGHT: Less mathematical bias, more practical focus\n\n" +
  "🎯 TRADING PERSONALITY:\n" +
  "• Mathematical Traders: 0.35-0.45\n" +
  "• Practical Traders: 0.15-0.25\n" +
  "• Balanced Approach: 0.25-0.35\n\n" +
  "🏦 ASSET CLASSES:\n" +
  "• Indices: 0.30-0.40 (mathematical patterns)\n" +
  "• Individual Stocks: 0.20-0.30 (more noise)\n" +
  "• Crypto: 0.25-0.35 (pure math markets)")

galois_weight = input.float(0.2, "⚡ Galois Rank Weight", minval=0.1, maxval=0.5, step=0.05, group=group_scoring,
  tooltip="🎯 WHAT IT IS: Market structure complexity and volatility regime influence\n\n" +
  "⚡ HOW IT WORKS: Measures market stress and structural changes\n\n" +
  "📈 HIGHER WEIGHT: More focus on volatility and market stress signals\n" +
  "📉 LOWER WEIGHT: Less emphasis on market structure changes\n\n" +
  "🌊 MARKET CONDITIONS:\n" +
  "• High Volatility Periods: 0.25-0.35\n" +
  "• Low Volatility Periods: 0.15-0.25\n" +
  "• Transition Periods: 0.30-0.40\n\n" +
  "🎯 STRATEGY FOCUS:\n" +
  "• Volatility Traders: 0.30-0.40\n" +
  "• Trend Followers: 0.15-0.25\n" +
  "• Market Structure: 0.25-0.35")

operadic_weight = input.float(0.3, "🌀 Operadic Composition Weight", minval=0.1, maxval=0.5, step=0.05, group=group_scoring,
  tooltip="🎯 WHAT IT IS: Multi-strategy consensus importance in final decision\n\n" +
  "⚡ HOW IT WORKS: Democratic weight of all composed trading algorithms\n\n" +
  "📈 HIGHER WEIGHT: Trust the wisdom of crowds approach\n" +
  "📉 LOWER WEIGHT: More mathematical/theoretical focus\n\n" +
  "🎭 TRADING PHILOSOPHY:\n" +
  "• Systematic Traders: 0.35-0.45\n" +
  "• Discretionary Traders: 0.20-0.30\n" +
  "• Hybrid Approach: 0.25-0.35\n\n" +
  "💡 RELIABILITY: Higher operadic weight typically improves win rates\n" +
  "🎯 OPTIMAL: Balance with other weights for best performance")

correspondence_weight = input.float(0.2, "🔗 Correspondence Quality Weight", minval=0.1, maxval=0.5, step=0.05, group=group_scoring,
  tooltip="🎯 WHAT IT IS: Theory-practice alignment quality measure\n\n" +
  "⚡ HOW IT WORKS: Measures how well mathematical theory matches market reality\n\n" +
  "📈 HIGHER WEIGHT: Demand strong theory-practice agreement\n" +
  "📉 LOWER WEIGHT: Accept some theory-practice divergence\n\n" +
  "🔬 MARKET EFFICIENCY:\n" +
  "• Efficient Markets: 0.25-0.35 (theory works)\n" +
  "• Inefficient Markets: 0.15-0.25 (theory breaks)\n" +
  "• Mixed Efficiency: 0.20-0.30\n\n" +
  "🎯 SIGNAL QUALITY:\n" +
  "• Quality Over Quantity: 0.25-0.35\n" +
  "• Quantity Over Quality: 0.15-0.25\n\n" +
  "💡 NOTE: Weight sum should ≈ 1.0 for optimal balance")

score_threshold = input.float(5.0, "🎯 Signal Score Threshold (0-10)", minval=0.5, maxval=10.0, step=0.5, group=group_scoring,
  tooltip="🎯 WHAT IT IS: Minimum score required for signal generation (-10 to +10 scale)\n\n" +
  "⚡ HOW IT WORKS: Quality filter - only scores above/below threshold trigger signals\n\n" +
  "📈 HIGHER THRESHOLD: Fewer but higher quality signals\n" +
  "📉 LOWER THRESHOLD: More signals but potentially more noise\n\n" +
  "🎯 TRADING FREQUENCY:\n" +
  "• Conservative (2-5 signals/day): 6.0-8.0\n" +
  "• Moderate (5-10 signals/day): 4.0-6.0\n" +
  "• Active (10+ signals/day): 2.0-4.0\n\n" +
  "🏆 QUALITY LEVELS:\n" +
  "• 8.0+: EXCEPTIONAL signals only\n" +
  "• 6.0-7.9: STRONG signals\n" +
  "• 4.0-5.9: MODERATE signals\n" +
  "• 2.0-3.9: WEAK signals\n\n" +
  "💡 BACKTESTING TIP: Start high (7.0+) then adjust based on frequency needs")

//==============================================================================
// 🌌 VISUAL CONFIGURATION
//==============================================================================
group_visual = "🌌 Visual Configuration"

visual_theme = input.string("Quantum", "🎨 Visual Theme", options=["Quantum", "Holographic", "Crystalline", "Plasma", "Cosmic Neon"], group=group_visual,
  tooltip="🎯 WHAT IT IS: Color scheme and visual personality of the indicator\n\n" +
  "🌈 THEME PERSONALITIES:\n" +
  "• 🔮 QUANTUM: Purple/violet - General trading, mathematical focus\n" +
  "• 🌊 HOLOGRAPHIC: Cyan/magenta - Crypto trading, digital assets\n" +
  "• 💎 CRYSTALLINE: Blue/turquoise - Conservative trading, stability\n" +
  "• 🔥 PLASMA: Gold/magenta - High energy trading, volatility\n" +
  "• 🚀 COSMIC NEON: Bright neon - Aggressive trading, maximum visibility\n\n" +
  "🎯 MARKET MATCHING:\n" +
  "• Traditional Markets: Quantum, Crystalline\n" +
  "• Crypto Markets: Holographic, Cosmic Neon\n" +
  "• Commodities: Plasma, Crystalline\n" +
  "• Forex: Quantum, Holographic\n\n" +
  "💡 PRO TIP: Match theme to your trading personality for better visual comfort")

showFractalGrid = input.bool(true, "📐 Show Fractal Grid (Key Levels)", group=group_visual,
  tooltip="🎯 WHAT IT IS: Dynamic support/resistance levels with projected L-Scores\n\n" +
  "⚡ HOW IT WORKS: Calculates fractal highs/lows with estimated signal scores\n\n" +
  "📈 BENEFITS: Precise entry/exit timing, projected signal strength\n" +
  "📉 DRAWBACKS: Can clutter chart on lower timeframes\n\n" +
  "🕒 RECOMMENDED FOR:\n" +
  "• Swing Trading: Always ON\n" +
  "• Day Trading: ON for major levels\n" +
  "• Scalping: OFF (too cluttered)\n\n" +
  "💡 USAGE: Watch for price approach to grid levels + high L-Score projections")

show_signal_portals = input.bool(true, "🌀 Signal Portals & Effects", group=group_visual,
  tooltip="🎯 WHAT IT IS: Entry signals with directional flow visualization\n\n" +
  "⚡ FEATURES:\n" +
  "• Triangle markers for entries\n" +
  "• Colored portal effects showing flow direction\n" +
  "• Morphism recursion patterns\n\n" +
  "🎯 VISUAL BENEFITS:\n" +
  "• Instant signal recognition\n" +
  "• Flow direction clarity\n" +
  "• Market momentum visualization\n\n" +
  "💡 OPTIMIZATION: Turn OFF for cleaner charts, ON for maximum information")

show_aether_flow = input.bool(true, "🌊 Show Aether Flow Background", group=group_visual,
  tooltip="🎯 WHAT IT IS: Background intensity heatmap showing market regime strength\n\n" +
  "⚡ HOW IT WORKS: Combines trend, momentum, volatility, and score intensity\n\n" +
  "🎨 INTENSITY LEVELS:\n" +
  "• Black/Dark: Low activity, range-bound\n" +
  "• Purple Glow: Moderate activity, building momentum  \n" +
  "• Bright Purple: High activity, strong trends\n" +
  "• Intense Glow: Extreme activity, major moves\n\n" +
  "🎯 TRADING INSIGHT: Bright backgrounds = high probability setups\n" +
  "💡 PRO TIP: Trade more aggressively when background is bright")

field_transparency = input.int(85, "🌫️ Field Transparency", minval=70, maxval=95, group=group_visual,
  tooltip="🎯 WHAT IT IS: Transparency level for quantum aura bands and background\n\n" +
  "⚡ SETTINGS:\n" +
  "• 70-75: More visible, stronger visual impact\n" +
  "• 80-85: Balanced visibility\n" +
  "• 90-95: Subtle, minimal interference\n\n" +
  "🎯 CHART PREFERENCES:\n" +
  "• Clean Charts: 90-95\n" +
  "• Balanced: 80-87\n" +
  "• Full Visual: 70-80\n\n" +
  "💡 OPTIMIZATION: Adjust based on chart background and personal preference")

show_morphism_flow = input.bool(true, "🌀 Show Morphism Flow (Portals)", group=group_visual,
  tooltip="🎯 WHAT IT IS: Advanced geometric patterns showing market flow topology\n\n" +
  "⚡ VISUAL ELEMENTS:\n" +
  "• Layered circular portals\n" +
  "• Directional color coding\n" +
  "• Recursive depth patterns\n\n" +
  "🎨 COLOR MEANING:\n" +
  "• Green/Cyan: Bullish flow\n" +
  "• Red/Orange: Bearish flow\n" +
  "• Size: Flow strength\n\n" +
  "🎯 USAGE: Helps visualize market sentiment and momentum direction\n" +
  "💡 ADVANCED: Based on category theory and topological data analysis")

visual_transparency = input.int(60, "🌫️ Morphism Flow Transparency", minval=0, maxval=100, group=group_visual,
  tooltip="🎯 CONTROL: Transparency of portal effects and morphism patterns\n\n" +
  "⚡ SETTINGS:\n" +
  "• 0-30: Very visible, strong impact\n" +
  "• 40-70: Balanced visibility\n" +
  "• 80-100: Subtle/invisible\n\n" +
  "🎯 OPTIMIZATION: Balance visual appeal with chart readability")

type_recursion_depth = input.int(4, "🔄 Morphism Recursion Depth", minval=1, maxval=8, group=group_visual,
  tooltip="🎯 WHAT IT IS: Number of recursive portal layers for pattern analysis\n\n" +
  "⚡ HOW IT WORKS: Creates nested geometric patterns showing flow evolution\n\n" +
  "📈 HIGHER DEPTH: More complex patterns, deeper analysis\n" +
  "📉 LOWER DEPTH: Simpler patterns, less CPU usage\n\n" +
  "🎯 PERFORMANCE OPTIMIZATION:\n" +
  "• Fast Charts: 2-4 depth\n" +
  "• Detailed Analysis: 4-6 depth\n" +
  "• Maximum Insight: 6-8 depth\n\n" +
  "💡 BALANCE: More depth = more insight but also more visual complexity")

show_wick_pressure = input.bool(true, "⚡ Show Wick Pressure Lines", group=group_visual,
  tooltip="🎯 WHAT IT IS: Rejection level analysis using candle wick patterns\n\n" +
  "⚡ HOW IT WORKS: Projects lines from significant wicks to show pressure zones\n\n" +
  "📈 UPPER WICKS: Show selling pressure and resistance\n" +
  "📉 LOWER WICKS: Show buying pressure and support\n\n" +
  "🎯 TRADING APPLICATION:\n" +
  "• Entry: Trade bounces off wick pressure zones\n" +
  "• Exit: Watch for wick pressure breakdown\n" +
  "• Confluence: Combine with fractal grid levels\n\n" +
  "💡 PRO TIP: Multiple wick pressure lines = stronger S/R zones")

glowIntensity = input.int(4, "✨ Wick Glow Intensity", minval=1, maxval=8, group=group_visual,
  tooltip="🎯 WHAT IT IS: Visual intensity and reach of wick pressure line effects\n\n" +
  "⚡ INTENSITY LEVELS:\n" +
  "• 1-2: Minimal glow, subtle lines\n" +
  "• 3-5: Moderate glow, balanced visibility\n" +
  "• 6-8: Maximum glow, strong visual impact\n\n" +
  "🎯 CHART OPTIMIZATION:\n" +
  "• Busy Charts: 2-4 intensity\n" +
  "• Clean Charts: 4-6 intensity\n" +
  "• Dramatic Effect: 6-8 intensity\n\n" +
  "💡 PERFORMANCE: Higher intensity uses more visual resources")

//==============================================================================
// 📊 DASHBOARD CONFIGURATION
//==============================================================================
group_dashboard_main = "📊 Dashboard Configuration"

show_dashboard = input.bool(true, "📋 Show Enhanced Dashboard", group=group_dashboard_main,
  tooltip="🎯 WHAT IT IS: Comprehensive information panel with all key metrics\n\n" +
  "📊 DASHBOARD INCLUDES:\n" +
  "• Unified AI Score with quality rating\n" +
  "• Component breakdowns (L-Function, Galois, etc.)\n" +
  "• OFPI analysis with momentum detection\n" +
  "• Signal performance statistics\n" +
  "• Current position details\n" +
  "• Möbius field strength\n\n" +
  "🎯 BENEFITS:\n" +
  "• Quick decision making\n" +
  "• Performance tracking\n" +
  "• Market regime awareness\n\n" +
  "💡 RECOMMENDED: Always ON for systematic trading")

dashboard_size = input.string("Normal", "📏 Dashboard Size", options=["Small", "Normal", "Large"], group=group_dashboard_main,
  tooltip="🎯 SIZE OPTIMIZATION:\n\n" +
  "📱 SMALL: Essential metrics only, minimal screen space\n" +
  "• Best for: Mobile, small screens, overlay trading\n" +
  "• Shows: Score, position, basic stats\n\n" +
  "💻 NORMAL: Balanced information and space usage\n" +
  "• Best for: Desktop trading, general use\n" +
  "• Shows: All core metrics with OFPI analysis\n\n" +
  "🖥️ LARGE: Maximum information detail\n" +
  "• Best for: Multiple monitors, detailed analysis\n" +
  "• Shows: Everything including extended breakdowns\n\n" +
  "💡 RECOMMENDATION: Start with Normal, adjust based on screen space")

dashboard_position_input = input.string("Top Right", "📍 Dashboard Position", options=["Top Left", "Top Right", "Bottom Left", "Bottom Right"], group=group_dashboard_main,
  tooltip="🎯 POSITIONING STRATEGY:\n\n" +
  "📍 TOP RIGHT: Classic placement, doesn't block price action\n" +
  "• Best for: Right-handed traders, standard setups\n\n" +
  "📍 TOP LEFT: Alternative placement for wider charts\n" +
  "• Best for: Ultra-wide monitors, left-handed preference\n\n" +
  "📍 BOTTOM RIGHT: Keeps focus on recent price action\n" +
  "• Best for: Short-term trading, scalping\n\n" +
  "📍 BOTTOM LEFT: Maximum price visibility\n" +
  "• Best for: Swing trading, longer-term analysis\n\n" +
  "💡 TIP: Choose position that doesn't interfere with your key chart areas")

//==============================================================================
// 🔧 VARIABLE DECLARATIONS - MUST BE AFTER INPUTS
//==============================================================================
// Fixed volatility calculation for consistency
atr_14 = ta.atr(14)
volatility_percentile = ta.percentrank(atr_14, 100)

// Variables that need to be declared for dashboard use
var float entry_price = na
var int direction = 0
var int last_signal_bar = 0
var int total_signals = 0
var int winning_signals = 0
var int max_mobius_n = 50
var bool show_warning = false


//==============================================================================
// THEME COLORS (Quantum Default)
//==============================================================================
get_theme_colors() => visual_theme == "Holographic" ? array.from(#00ffff, #ff00ff, #ffff00, #00ff00, #ff0066, #808080) : visual_theme == "Crystalline" ? array.from(#4169e1, #9370db, #00ced1, #da70d6, #7b68ee, #b0c4de) : visual_theme == "Plasma" ? array.from(#ff1493, #ff4500, #ffd700, #ff69b4, #dc143c, #ffdab9) : visual_theme == "Cosmic Neon" ? array.from(#ff073a, #00f9ff, #39ff14, #f8f32b, #ff40e0, #ffffff) : array.from(#9400d3, #4b0082, #0000ff, #00ff00, #ff0000, #808080)

// Using the safe assignment method by getting each element from the returned array.
var theme_array = get_theme_colors()
color c1 = array.get(theme_array, 0)
color c2 = array.get(theme_array, 1)
color c3 = array.get(theme_array, 2)
color c4 = array.get(theme_array, 3)
color c5 = array.get(theme_array, 4)
color c_neutral = array.get(theme_array, 5)

// Custom portal colors
portal_color_outer = color.new(#2a003f, 85)
portal_color_inner = color.new(#a259ff, 60)
primaryBull = color.new(#a259ff, 0)
primaryBear = color.new(#2a003f, 0)

//==============================================================================
// FRACTAL GRID COLORS (auto-match theme, no extra inputs)
//==============================================================================
// CORRECTED: Replaced invalid [...] array creation with array.from()
get_fractal_colors() => visual_theme == "Holographic" ? array.from(color.new(#00ff00, 70), color.new(#00ff00, 10), color.new(#ff0066, 70), color.new(#ff0066, 10)) : visual_theme == "Crystalline" ? array.from(color.new(#00ced1, 70), color.new(#00ced1, 10), color.new(#9370db, 70), color.new(#9370db, 10)) : visual_theme == "Plasma" ? array.from(color.new(#ffd700, 70), color.new(#ffd700, 10), color.new(#ff1493, 70), color.new(#ff1493, 10)) : visual_theme == "Cosmic Neon" ? array.from(color.new(#39ff14, 70), color.new(#39ff14, 10), color.new(#ff073a, 70), color.new(#ff073a, 10)) : array.from(color.new(#00ff00, 70), color.new(#00ff00, 10), color.new(#ff0000, 70), color.new(#ff0000, 10))

// Using the safe assignment method to avoid any issues with [...]
var fractal_color_array = get_fractal_colors()
color fractalHighGlow = array.get(fractal_color_array, 0)
color fractalHighSharp = array.get(fractal_color_array, 1)
color fractalLowGlow = array.get(fractal_color_array, 2)
color fractalLowSharp = array.get(fractal_color_array, 3)

//==============================================================================
// ADVANCED THEORY FUNCTIONS
//==============================================================================
tanh(x) => (math.exp(x) - math.exp(-x)) / (math.exp(x) + math.exp(-x))

//==============================================================================
// STATIC MÖBIUS ARRAY (FAST, NO TIMEOUT)
//==============================================================================
var float[] mobius_arr = array.from(0.0, 1.0, -1.0, -1.0, 0.0, -1.0, 1.0, -1.0, 0.0, 0.0, 1.0, -1.0, 1.0, -1.0, 0.0, 1.0, 0.0, -1.0, 1.0, 1.0, 0.0, -1.0, 1.0, 0.0, 0.0, 1.0, 1.0, -1.0, 1.0, 0.0, 0.0, -1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, -1.0, 1.0, 1.0, 0.0, 1.0, 0.0, -1.0, 1.0, 0.0, 0.0, 1.0)
//==============================================================================
// HTF (NON-REPAINT) FEATURES
//==============================================================================
htf_close = request.security(syminfo.tickerid, htf_tf, close, lookahead=barmerge.lookahead_off)
htf_rsi = request.security(syminfo.tickerid, htf_tf, ta.rsi(close, 14), lookahead=barmerge.lookahead_off)
htf_sma50 = request.security(syminfo.tickerid, htf_tf, ta.sma(close, 50), lookahead=barmerge.lookahead_off)
htf_trend = htf_close > htf_sma50 ? 1 : htf_close < htf_sma50 ? -1 : 0
htf_vol = request.security(syminfo.tickerid, htf_tf, ta.atr(14), lookahead=barmerge.lookahead_off)

//==============================================================================
// ORDER FLOW POLARITY INDEX (OFPI) INTEGRATION
//==============================================================================
calculate_ofpi(len, t3_len, t3_vf) =>
    body_pos = (close - low) / (high - low + 1e-6)
    buy_vol = volume * body_pos
    sell_vol = volume * (1 - body_pos)
    net_aggr_vol = buy_vol - sell_vol
    ofpi_raw = 0.0
    total_vol = 0.0
    for i = 0 to len - 1
        if i <= bar_index
            ofpi_raw += nz(net_aggr_vol[i])
            total_vol += nz(volume[i])
    ofpi = total_vol != 0 ? ofpi_raw / total_vol : 0
    e1 = ta.ema(ofpi, t3_len)
    e2 = ta.ema(e1, t3_len)
    e3 = ta.ema(e2, t3_len)
    e4 = ta.ema(e3, t3_len)
    e5 = ta.ema(e4, t3_len)
    e6 = ta.ema(e5, t3_len)
    t3_c1 = -t3_vf * t3_vf * t3_vf
    t3_c2 = 3 * t3_vf * t3_vf + 3 * t3_vf * t3_vf * t3_vf
    t3_c3 = -6 * t3_vf * t3_vf - 3 * t3_vf - 3 * t3_vf * t3_vf * t3_vf
    t3_c4 = 1 + 3 * t3_vf + t3_vf * t3_vf * t3_vf + 3 * t3_vf * t3_vf
    t3_c1 * e6 + t3_c2 * e5 + t3_c3 * e4 + t3_c4 * e3

detect_momentum_shift(ofpi_current, ofpi_prev1, ofpi_prev2) => (ofpi_prev1 > ofpi_prev2 and ofpi_current < ofpi_prev1) or (ofpi_prev1 < ofpi_prev2 and ofpi_current > ofpi_prev1)

ofpi_value = calculate_ofpi(ofpi_length, ofpi_t3_length, ofpi_t3_vfactor)
momentum_shifting = detect_momentum_shift(ofpi_value, ofpi_value[1], ofpi_value[2])

//==============================================================================
// CORE LOGIC & CALCULATIONS
//==============================================================================
type LanglandsState
    float L_value
    float normalized_L
    float frobenius_trace
    float galois_rank
    float correspondence_error
    float trend_alignment
    float htf_trend

type OperadicStrategy
    string name
    float signal
    float confidence
    float weight

frobenius_corr = ta.correlation(close, volume, math.min(frobenius_lookback, bar_index+1))
galois_rank_val = ta.percentrank(ta.atr(14), math.min(frobenius_lookback, bar_index+1)) / 100
sma50_val = ta.sma(close, 50)

calculate_langlands_state(lookback_period, frobenius_corr, galois_rank_val, sma50_val) =>
    if bar_index < 20
        LanglandsState.new(0, 0, 0, 0, 0, 0, 0)
    else
        state = LanglandsState.new()
        L_sum = 0.0
        weight_sum = 0.0
        max_n = math.min(lookback_period, bar_index, max_mobius_n)
        for n = 1 to max_n
            if n <= bar_index
                return_val = (close[n-1] - close[n]) / close[n]
                mob = array.get(mobius_arr, n)
                weight = mob / math.pow(n, l_function_precision)
                L_sum += return_val * weight * 100
                weight_sum += math.abs(weight)
        state.L_value := weight_sum > 0 ? L_sum / weight_sum : 0.001
        x = state.L_value
        state.normalized_L := tanh(x)
        state.frobenius_trace := frobenius_corr
        state.galois_rank := galois_rank_val
        state.correspondence_error := math.abs(state.normalized_L - nz(frobenius_corr))
        state.trend_alignment := close > sma50_val ? 1 : close < sma50_val ? -1 : 0
        state.htf_trend := htf_trend
        state

create_base_strategies() =>
    strats = array.new<OperadicStrategy>()
    rsi_val = ta.rsi(close, 14)
    array.push(strats, OperadicStrategy.new("Momentum", (rsi_val - 50) / 50, math.abs(rsi_val - 50) / 50, 1.0))
    bb_middle = ta.sma(close, 20)
    bb_width = ta.stdev(close, 20) * 2
    array.push(strats, OperadicStrategy.new("Reversion", -(close - bb_middle) / bb_width, math.abs((close - bb_middle) / bb_width), 1.0))
    ofpi_signal = momentum_shifting ? ofpi_value * 1.5 : ofpi_value
    ofpi_confidence = momentum_shifting ? math.min(1.0, math.abs(ofpi_value) * 1.3) : math.abs(ofpi_value)
    array.push(strats, OperadicStrategy.new("Order Flow", ofpi_signal, ofpi_confidence, 1.2))
    [pdi, mdi, adx_val] = ta.dmi(14, 14)
    array.push(strats, OperadicStrategy.new("Trend", (adx_val - 25) / 25, math.abs(adx_val - 25) / 25, 1.0))
    htf_rsi_norm = (htf_rsi - 50) / 50
    array.push(strats, OperadicStrategy.new("HTF Momentum", htf_rsi_norm, math.abs(htf_rsi_norm), 1.0))
    final_strats = array.new<OperadicStrategy>()
    num_to_take = math.min(array.size(strats), composition_arity)
    for i = 0 to num_to_take - 1
        array.push(final_strats, array.get(strats, i))
    final_strats

category_agreement(strategies, required) =>
    up = 0
    down = 0
    for i = 0 to array.size(strategies) - 1
        s = array.get(strategies, i)
        if s.signal > 0.2
            up += 1
        if s.signal < -0.2
            down += 1
    up >= required ? 1 : down >= required ? -1 : 0

compose_strategies(strategies, langlands_state) =>
    total_signal = 0.0
    total_weight = 0.0
    for i = 0 to array.size(strategies) - 1
        s = array.get(strategies, i)
        w = s.confidence
        total_signal += s.signal * w
        total_weight += w
    base_signal = total_weight > 0 ? total_signal / total_weight : 0
    final_signal = base_signal * (1 + langlands_state.trend_alignment * swiss_cheese_weight) * (1 + langlands_state.htf_trend * swiss_cheese_weight)
    math.max(-1, math.min(1, final_signal))

calculate_unified_score(lang_state, composite_signal) =>
    l_score = lang_state.normalized_L
    market_stress = ta.atr(14) > ta.sma(ta.atr(14), 20) * 1.2
    g_score = market_stress ? -lang_state.galois_rank : lang_state.galois_rank
    if lang_state.htf_trend < 0
        g_score := -math.abs(g_score)
    o_score = composite_signal
    c_base = 1 - lang_state.correspondence_error
    c_score = c_base * math.sign(o_score)
    total_score = l_score * l_function_weight + g_score * galois_weight + o_score * operadic_weight + c_score * correspondence_weight
    if total_score < 0
        total_score := total_score * 2.5
    if ofpi_value < -0.1 and total_score < 0
        total_score := total_score * 1.3
    total_score := math.max(-1, math.min(1, total_score))
    total_score_display = total_score * 10

//==============================================================================
// ENHANCED SIGNAL LOGIC WITH BALANCED LONG/SHORT GENERATION
//==============================================================================
var int continuation_count = 0

atr14 = ta.atr(14)
modular_level_capped = math.min(modular_level, max_mobius_n)
lang_state = calculate_langlands_state(modular_level_capped, frobenius_corr, galois_rank_val, sma50_val)
base_strategies = create_base_strategies()
composite_signal = compose_strategies(base_strategies, lang_state)
agreement_direction = category_agreement(base_strategies, agreement_required)

calculate_unified_score_asymmetric(lang_state, composite_signal) =>
    l_score = lang_state.normalized_L
    market_stress = ta.atr(14) > ta.sma(ta.atr(14), 20) * 1.2
    g_score = market_stress ? -lang_state.galois_rank : lang_state.galois_rank
    if lang_state.htf_trend < 0
        g_score := -math.abs(g_score)
    o_score = composite_signal
    c_base = 1 - lang_state.correspondence_error
    c_score = c_base * math.sign(o_score)
    total_score = l_score * l_function_weight + g_score * galois_weight + o_score * operadic_weight + c_score * correspondence_weight
    
    // BALANCED AMPLIFICATION FOR LONGS
    if total_score > 0
        total_score := total_score * 1.5 // Same base multiplier as shorts
        if not market_stress  // Longs prefer calm markets
            total_score := total_score * 1.2
        if ofpi_value > 0.1  // Bullish order flow
            total_score := total_score * 1.3
        if lang_state.htf_trend > 0  // Higher timeframe bullish
            total_score := total_score * 1.15
    
    // KEEP ORIGINAL SHORT AMPLIFICATION
    if total_score < 0
        total_score := total_score * 1.5
        if market_stress
            total_score := total_score * 1.2
        if ofpi_value < -0.1
            total_score := total_score * 1.3
        if lang_state.htf_trend < 0
            total_score := total_score * 1.15
    
    total_score := math.max(-1, math.min(1, total_score))
    total_score_display = total_score * 10
    components = array.from(l_score, g_score, o_score, c_score)
    mean_component = array.avg(components)
    variance_sum = 0.0
    for i = 0 to 3
        variance_sum += math.pow(array.get(components, i) - mean_component, 2)
    agreement = math.sqrt(variance_sum / 4)
    signal_quality = agreement < 0.2 ? "EXCEPTIONAL" : agreement < 0.4 ? "STRONG" : agreement < 0.6 ? "MODERATE" : "WEAK"
    [total_score_display, signal_quality]

[total_score_display, signal_quality] = calculate_unified_score_asymmetric(lang_state, composite_signal)

volatility_ok = ta.atr(14) > ta.sma(ta.atr(14), 50) * 0.8 and htf_vol > ta.sma(htf_vol, 20) * 0.8
trend_ok = lang_state.trend_alignment != 0 or lang_state.htf_trend != 0
signal_ok = volatility_ok and trend_ok
can_signal = bar_index - last_signal_bar > 10
ofpi_threshold = 0.15
strong_bullish_flow = ofpi_value > ofpi_threshold
strong_bearish_flow = ofpi_value < -ofpi_threshold
flow_accelerating = math.abs(ofpi_value) > math.abs(ofpi_value[1])

// BALANCED THRESHOLDS - BOTH USE SAME MULTIPLIER
long_threshold = score_threshold * 0.6
short_threshold = score_threshold * 0.8

// Pattern Recognition
bearish_engulfing = close < open and close[1] > open[1] and open > close[1] and close < open[1]
three_black_crows = close < open and close[1] < open[1] and close[2] < open[2] and close < close[1] and close[1] < close[2]
evening_star = close[2] > open[2] and math.abs(close[1] - open[1]) < (high[1] - low[1]) * 0.3 and close < open and close < close[2]
bearish_pattern = bearish_engulfing or three_black_crows or evening_star

bullish_engulfing = close > open and close[1] < open[1] and open < close[1] and close > open[1]
morning_star = close[2] < open[2] and math.abs(close[1] - open[1]) < (high[1] - low[1]) * 0.3 and close > open and close > close[2]
three_white_soldiers = close > open and close[1] > open[1] and close[2] > open[2] and close > close[1] and close[1] > close[2]
bullish_pattern = bullish_engulfing or morning_star or three_white_soldiers

// BALANCED ENTRY CONDITIONS - PARALLEL STRUCTURE FOR BOTH
// Long entry - multiple paths like shorts have
long_entry = direction == 0 and can_signal and 
             ((signal_ok and total_score_display > long_threshold and (agreement_direction == 1 or agreement_direction == 0)) or 
              (strong_bullish_flow and composite_signal > 0.2) or 
              (bullish_pattern and total_score_display > long_threshold * 0.5 and ofpi_value > 0) or 
              (lang_state.htf_trend > 0 and momentum_shifting and ofpi_value > 0) or 
              (ofpi_value > 0.3 and total_score_display > 0))

// Short entry - keep original structure
short_entry = direction == 0 and can_signal and 
              ((signal_ok and total_score_display < -short_threshold and (agreement_direction == -1 or agreement_direction == 0)) or 
               (strong_bearish_flow and composite_signal < -0.2) or 
               (bearish_pattern and total_score_display < -short_threshold * 0.5 and ofpi_value < 0) or 
               (lang_state.htf_trend < 0 and momentum_shifting and ofpi_value < 0) or 
               (ofpi_value < -0.3 and total_score_display < 0))

exit_long = direction == 1 and (total_score_display < 1.0 or not signal_ok or (ofpi_value < -ofpi_threshold and flow_accelerating))
exit_short = direction == -1 and (total_score_display > -1.0 or not signal_ok or (ofpi_value > ofpi_threshold and flow_accelerating))

if long_entry
    direction := 1
    entry_price := close
    continuation_count := 0
    last_signal_bar := bar_index
    total_signals += 1

if short_entry
    direction := -1
    entry_price := close
    continuation_count := 0
    last_signal_bar := bar_index
    total_signals += 1

if exit_long
    if close > entry_price
        winning_signals += 1
    direction := 0
    entry_price := na

if exit_short
    if close < entry_price
        winning_signals += 1
    direction := 0
    entry_price := na

//==============================================================================
// VISUALS: MULTI-SCALE RESONANCE BANDS (Quantum Aura)
//==============================================================================
field_center = ta.ema(close, 5)
field_amplitude = ta.atr(14) * (1 + math.abs(total_score_display) / 10 * 1.5)
band1_upper = field_center + field_amplitude * 0.75
band1_lower = field_center - field_amplitude * 0.75
band2_upper = field_center + field_amplitude * 1.0
band2_lower = field_center - field_amplitude * 1.0
band3_upper = field_center + field_amplitude * 1.25
band3_lower = field_center - field_amplitude * 1.25
band4_upper = field_center + field_amplitude * 1.5
band4_lower = field_center - field_amplitude * 1.5
band5_upper = field_center + field_amplitude * 1.75
band5_lower = field_center - field_amplitude * 1.75
p1u = plot(band1_upper, color=color.new(c1, field_transparency + 2), linewidth=1, title="Band 1 Upper")
p1l = plot(band1_lower, color=color.new(c1, field_transparency + 2), linewidth=1, title="Band 1 Lower")
fill(p1u, p1l, color=color.new(c1, field_transparency + 2))
p2u = plot(band2_upper, color=color.new(c1, field_transparency + 6), linewidth=1, title="Band 2 Upper")
p2l = plot(band2_lower, color=color.new(c1, field_transparency + 6), linewidth=1, title="Band 2 Lower")
fill(p2u, p2l, color=color.new(c1, field_transparency + 6))
p3u = plot(band3_upper, color=color.new(c1, field_transparency + 10), linewidth=1, title="Band 3 Upper")
p3l = plot(band3_lower, color=color.new(c1, field_transparency + 10), linewidth=1, title="Band 3 Lower")
fill(p3u, p3l, color=color.new(c1, field_transparency + 10))
p4u = plot(band4_upper, color=color.new(c1, field_transparency + 14), linewidth=1, title="Band 4 Upper")
p4l = plot(band4_lower, color=color.new(c1, field_transparency + 14), linewidth=1, title="Band 4 Lower")
fill(p4u, p4l, color=color.new(c1, field_transparency + 14))
p5u = plot(band5_upper, color=color.new(c1, field_transparency + 18), linewidth=1, title="Band 5 Upper")
p5l = plot(band5_lower, color=color.new(c1, field_transparency + 18), linewidth=1, title="Band 5 Lower")
fill(p5u, p5l, color=color.new(c1, field_transparency + 18))

//==============================================================================
// REGIME INTENSITY HEATMAP BACKGROUND
//==============================================================================
var color final_bg_color = na 

// Function to get purple/black/gray background colors based on theme
get_background_colors() =>
    if visual_theme == "Holographic"
        array.from(color.new(#8b00ff, 85), color.new(#4b0082, 88), color.new(#2d004d, 91), color.new(#1a0033, 94), color.new(#0d001a, 96), color.new(#000000, 97))
    else if visual_theme == "Crystalline"
        array.from(color.new(#9370db, 85), color.new(#6a5acd, 88), color.new(#483d8b, 91), color.new(#2e2b5f, 94), color.new(#1a1a2e, 96), color.new(#0f0f1e, 97))
    else if visual_theme == "Plasma"
        array.from(color.new(#da70d6, 85), color.new(#ba55d3, 88), color.new(#8b008b, 91), color.new(#4b0051, 94), color.new(#2d0033, 96), color.new(#1a001f, 97))
    else if visual_theme == "Cosmic Neon"
        array.from(color.new(#ff00ff, 85), color.new(#cc00cc, 88), color.new(#990099, 91), color.new(#660066, 94), color.new(#330033, 96), color.new(#1a001a, 97))
    else // Quantum (default)
        array.from(color.new(#9400d3, 85), color.new(#7b00b0, 88), color.new(#5e0087, 91), color.new(#40005e, 94), color.new(#2d0042, 96), color.new(#1a0026, 97))

if show_aether_flow
    trend_strength = math.abs(lang_state.trend_alignment + lang_state.htf_trend) / 2
    momentum_strength = math.abs(ofpi_value)
    volatility_regime = ta.atr(14) / ta.sma(ta.atr(14), 50)
    score_intensity = math.min(math.abs(total_score_display) / 10, 1)
    
    regime_intensity = (trend_strength + momentum_strength + volatility_regime + score_intensity) / 4
    
    // Get theme-specific background colors
    var bg_colors_array = get_background_colors()
    
    // Select color based on intensity (single line)
    bg_color = regime_intensity > 0.8 ? array.get(bg_colors_array, 0) : regime_intensity > 0.6 ? array.get(bg_colors_array, 1) : regime_intensity > 0.4 ? array.get(bg_colors_array, 2) : regime_intensity > 0.3 ? array.get(bg_colors_array, 3) : regime_intensity > 0.2 ? array.get(bg_colors_array, 4) : array.get(bg_colors_array, 5)
    
    // Additional dimming for neutral market conditions
    if math.abs(total_score_display) < 2.0
        bg_color := color.new(color.black, 95 + int(regime_intensity * 3))
    
    final_bg_color := bg_color
else
    final_bg_color := na

bgcolor(final_bg_color, title="Regime Intensity Heatmap")

//==============================================================================
// PORTAL EFFECT: TWO LAYERED CIRCLES WITH DIRECTIONAL COLORS
//==============================================================================
if show_morphism_flow
    composite_morphism_strength = math.abs(composite_signal)
    flow_strength = math.max(0.3, composite_morphism_strength)
    for i = 1 to type_recursion_depth
        if bar_index > i and i % 2 == 0
            y = (close + close[i]) / 2
            is_bearish = total_score_display < 0
            signal_strength = math.abs(total_score_display) / 10
            portal_outer = color.new(#000000, 100)
            portal_inner = color.new(#000000, 100)
            if visual_theme == "Quantum"
                portal_outer := is_bearish ? color.new(#ff0040, 40) : color.new(#00ff88, 40)
                portal_inner := is_bearish ? color.new(#ffaa00, 10) : color.new(#00ffff, 10)
            else if visual_theme == "Holographic"
                portal_outer := is_bearish ? color.new(#ff0066, 40) : color.new(#00ffff, 40)
                portal_inner := is_bearish ? color.new(#ffff00, 10) : color.new(#00ff00, 10)
            else if visual_theme == "Crystalline" 
                portal_outer := is_bearish ? color.new(#da70d6, 40) : color.new(#00ced1, 40)
                portal_inner := is_bearish ? color.new(#ff69b4, 10) : color.new(#7fffd4, 10)
            else if visual_theme == "Plasma"
                portal_outer := is_bearish ? color.new(#dc143c, 40) : color.new(#ffd700, 40)
                portal_inner := is_bearish ? color.new(#ff1493, 10) : color.new(#ffff00, 10)
            else if visual_theme == "Cosmic Neon"
                portal_outer := is_bearish ? color.new(#ff073a, 40) : color.new(#39ff14, 40)
                portal_inner := is_bearish ? color.new(#00f9ff, 10) : color.new(#ff40e0, 10)
            else
                portal_outer := is_bearish ? color.new(#ff0000, 40) : color.new(#00ff00, 40)
                portal_inner := is_bearish ? color.new(#ff8800, 10) : color.new(#00ffff, 10)
            label.new(bar_index - i, y, "●", color=portal_outer, textcolor=portal_outer, style=label.style_none, size=size.small)
            label.new(bar_index - i, y, "●", color=portal_inner, textcolor=portal_inner, style=label.style_none, size=size.tiny)

//==============================================================================
// WICK PRESSURE LINES (UNIQUE PURPLE TONES)
//==============================================================================
atr = ta.atr(14)
if show_wick_pressure and atr > 0
    upperWick = high - math.max(open, close)
    lowerWick = math.min(open, close) - low
    body = math.abs(close - open)
    for i = 1 to math.min(glowIntensity, 5)
        if bar_index > i
            if upperWick[i] > body[i] * 0.5
                wickAlpha = 20 + i * 8
                wickColor = color.new(primaryBear, wickAlpha)
                wickWidth = math.max(1, glowIntensity - i)
                line.new(bar_index - i, high[i], bar_index, high - (atr * 0.1), color=wickColor, width=wickWidth, style=line.style_dotted)
            if lowerWick[i] > body[i] * 0.5
                wickAlpha = 20 + i * 8
                wickColor = color.new(primaryBull, wickAlpha)
                wickWidth = math.max(1, glowIntensity - i)
                line.new(bar_index - i, low[i], bar_index, low + (atr * 0.1), color=wickColor, width=wickWidth, style=line.style_dotted)

//==============================================================================
// FRACTAL GRID: Neon Shadow + Dotted Highlight, Theme-Matched
//==============================================================================
// CORRECTED: Replaced invalid [...] array creation with array.from()
get_fractal_line_colors() => visual_theme == "Holographic" ? array.from(color.new(#00ffff, 0), color.new(#00ffff, 80), color.new(#ff00ff, 0), color.new(#ff00ff, 80)) : visual_theme == "Crystalline" ? array.from(color.new(#00ced1, 0), color.new(#00ced1, 80), color.new(#9370db, 0), color.new(#9370db, 80)) : visual_theme == "Plasma" ? array.from(color.new(#ffd700, 0), color.new(#ffd700, 80), color.new(#ff1493, 0), color.new(#ff1493, 80)) : visual_theme == "Cosmic Neon" ? array.from(color.new(#39ff14, 0), color.new(#39ff14, 80), color.new(#ff073a, 0), color.new(#ff073a, 80)) : array.from(color.new(#00ff00, 0), color.new(#00ff00, 80), color.new(#ff0000, 0), color.new(#ff0000, 80))

// Using the safe assignment method
var fractal_line_array = get_fractal_line_colors()
color fractalHighBase = array.get(fractal_line_array, 0)
color fractalHighDark = array.get(fractal_line_array, 1)
color fractalLowBase = array.get(fractal_line_array, 2)
color fractalLowDark = array.get(fractal_line_array, 3)

fractalHighs = array.from(ta.highest(high, 10), ta.highest(high, 20), ta.highest(high, 30), ta.highest(high, 40), ta.highest(high, 50))
fractalLows  = array.from(ta.lowest(low, 10),  ta.lowest(low, 20),  ta.lowest(low, 30),  ta.lowest(low, 40),  ta.lowest(low, 50))
var array<line> fractalHighGlowLines = array.new<line>()
var array<line> fractalHighHighlightLines = array.new<line>()
var array<line> fractalLowGlowLines = array.new<line>()
var array<line> fractalLowHighlightLines = array.new<line>()
var array<label> fractalHighLabels = array.new<label>()
var array<label> fractalLowLabels = array.new<label>()

if showFractalGrid and barstate.isrealtime
    for l in fractalHighGlowLines
        line.delete(l)
    for l in fractalHighHighlightLines
        line.delete(l)
    for l in fractalLowGlowLines
        line.delete(l)
    for l in fractalLowHighlightLines
        line.delete(l)
    for lbl in fractalHighLabels
        label.delete(lbl)
    for lbl in fractalLowLabels
        label.delete(lbl)
    array.clear(fractalHighGlowLines)
    array.clear(fractalHighHighlightLines)
    array.clear(fractalLowGlowLines)
    array.clear(fractalLowHighlightLines)
    array.clear(fractalHighLabels)
    array.clear(fractalLowLabels)
    for i = 0 to 4
        glowAlpha = 70 + i * 8
        highlightAlpha = 40 + i * 8
        hi = array.get(fractalHighs, i)
        if not na(hi)
            array.push(fractalHighGlowLines, line.new(bar_index - 14, hi, bar_index + 30, hi, color=color.new(fractalHighBase, glowAlpha), width=3, style=line.style_solid))
            array.push(fractalHighHighlightLines, line.new(bar_index - 15, hi, bar_index + 30, hi, color=color.new(fractalHighDark, highlightAlpha), width=1, style=line.style_dotted))
        lo = array.get(fractalLows, i)
        if not na(lo)
            array.push(fractalLowGlowLines, line.new(bar_index - 14, lo, bar_index + 30, lo, color=color.new(fractalLowBase, glowAlpha), width=3, style=line.style_solid))
            array.push(fractalLowHighlightLines, line.new(bar_index - 15, lo, bar_index + 30, lo, color=color.new(fractalLowDark, highlightAlpha), width=1, style=line.style_dotted))
    lookback_periods = array.from(10, 20, 30, 40, 50)
    used_positions = array.new<float>()
    min_spacing = atr14 * 0.15
    for i = 0 to 4
        hi = array.get(fractalHighs, i)
        lo = array.get(fractalLows, i)
        period = array.get(lookback_periods, i)
        if not na(hi)
            can_place = true
            if array.size(used_positions) > 0
                for j = 0 to array.size(used_positions) - 1
                    if math.abs(hi - array.get(used_positions, j)) < min_spacing
                        can_place := false
                        break
            if can_place
                price_impact = (hi - close) / atr14
                estimated_score = total_score_display - (price_impact * 3)
                hi_label_text = "R" + str.tostring(period) + ": " + str.tostring(hi, "#.##") + " | L-Score: " + str.tostring(estimated_score, "#.#")
                new_label = label.new(bar_index + 30, hi, hi_label_text, color=color.new(fractalHighBase, 85), textcolor=fractalHighBase, style=label.style_label_left, size=size.tiny)
                array.push(fractalHighLabels, new_label)
                array.push(used_positions, hi)
        if not na(lo)
            can_place = true
            if array.size(used_positions) > 0
                for j = 0 to array.size(used_positions) - 1
                    if math.abs(lo - array.get(used_positions, j)) < min_spacing
                        can_place := false
                        break
            if can_place
                price_impact = (close - lo) / atr14
                estimated_score = total_score_display + (price_impact * 3)
                lo_label_text = "S" + str.tostring(period) + ": " + str.tostring(lo, "#.##") + " | L-Score: " + str.tostring(estimated_score, "#.#")
                new_label = label.new(bar_index + 30, lo, lo_label_text, color=color.new(fractalLowBase, 85), textcolor=fractalLowBase, style=label.style_label_left, size=size.tiny)
                array.push(fractalLowLabels, new_label)
                array.push(used_positions, lo)
//==============================================================================
// SIGNAL LABELS (LONG/SHORT) 
//==============================================================================
plotshape(show_signal_portals and long_entry, style=shape.triangleup, location=location.belowbar, color=color.new(c4, 0), size=size.small, offset=1, title="Long Entry")
plotshape(show_signal_portals and short_entry, style=shape.triangledown, location=location.abovebar, color=color.new(c5, 0), size=size.small, offset=1, title="Short Entry")
//==============================================================================
// ENHANCED DASHBOARD WITH COMPLETE OFPI INTEGRATION
//==============================================================================
var table dashboard = na
if show_dashboard and barstate.islast
    // Dashboard positioning and sizing
    dashboard_pos = dashboard_position_input == "Top Left" ? position.top_left : dashboard_position_input == "Top Right" ? position.top_right : dashboard_position_input == "Bottom Left" ? position.bottom_left : position.bottom_right
    cols = dashboard_size == "Large" ? 5 : 4
    rows = dashboard_size == "Large" ? 25 : dashboard_size == "Normal" ? 22 : 16

    // Clean up existing dashboard
    if not na(dashboard)
        table.delete(dashboard)
    
    // Create new dashboard
    dashboard := table.new(dashboard_pos, cols, rows, border_width = 1, border_color = color.new(c_neutral, 50), bgcolor = color.new(#1e222d, 20))
    
    // Color scheme
    dc_white = color.white
    dc_gray = #B2B5BE
    dc_green = #26A69A
    dc_red = #EF5350
    dc_gold = #FFD700
    dc_purple = c1
    dc_aqua = c3
    dc_orange = #FF8C00
    dc_cyan = #00FFFF
    bg_header = color.new(color.black, 30)
    bg_section = color.new(color.gray, 85)
    
    // Text sizing
    header_size = dashboard_size == "Large" ? size.normal : size.small
    value_size = dashboard_size == "Large" ? size.normal : size.small
    label_size = dashboard_size == "Large" ? size.small : size.tiny
    
    current_row = 0
    
    // ═══ MAIN HEADER ═══
    table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
    table.cell(dashboard, 0, current_row, "🛸 Langlands-Operadic Möbius Vortex | " + syminfo.ticker, text_halign=text.align_center, text_color=dc_white, bgcolor=bg_header, text_size=header_size)
    current_row += 1
    
    // Warning for modular level cap
    if show_warning
        table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
        table.cell(dashboard, 0, current_row, "⚠️ Modular Level capped at " + str.tostring(max_mobius_n) + " for performance", text_color=dc_red, text_size=label_size)
        current_row += 1
    
    // ═══ UNIFIED AI SCORE SECTION ═══
    table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
    table.cell(dashboard, 0, current_row, "═══ 🎯 UNIFIED AI SCORE ═══", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
    current_row += 1
    
    // Total Score
    table.cell(dashboard, 0, current_row, "TOTAL SCORE", text_color=dc_gray, text_size=label_size)
    table.merge_cells(dashboard, 1, current_row, cols - 1, current_row)
    score_color = signal_quality == "EXCEPTIONAL" ? dc_gold : signal_quality == "STRONG" ? dc_green : signal_quality == "MODERATE" ? dc_aqua : dc_gray
    table.cell(dashboard, 1, current_row, str.tostring(-total_score_display, "#.##"), text_halign=text.align_right, text_color=score_color, text_size=value_size)
    current_row += 1
    
    // Signal Quality
    table.cell(dashboard, 0, current_row, "Quality", text_color=dc_gray, text_size=label_size)
    table.merge_cells(dashboard, 1, current_row, cols - 1, current_row)
    quality_emoji = signal_quality == "EXCEPTIONAL" ? "🌟" : signal_quality == "STRONG" ? "💪" : signal_quality == "MODERATE" ? "👍" : "⚠️"
    table.cell(dashboard, 1, current_row, quality_emoji + " " + signal_quality, text_halign=text.align_right, text_color=score_color, text_size=value_size)
    current_row += 1
    
    // Component Contributions (Normal and Large only)
    if dashboard_size != "Small"
        table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
        table.cell(dashboard, 0, current_row, "📊 Component Analysis", text_halign=text.align_center, text_color=dc_aqua, text_size=label_size)
        current_row += 1
        
        // L-Function & Galois
        table.cell(dashboard, 0, current_row, "L-Function", text_color=dc_gray, text_size=label_size)
        l_func_color = math.abs(lang_state.L_value) > 1.0 ? dc_purple : dc_gray
        table.cell(dashboard, 1, current_row, str.tostring(lang_state.L_value, "#.###"), text_halign=text.align_right, text_color=l_func_color, text_size=label_size)
        table.cell(dashboard, 2, current_row, "Galois", text_color=dc_gray, text_size=label_size)
        galois_color = lang_state.galois_rank > 0.7 ? dc_red : lang_state.galois_rank > 0.3 ? dc_orange : dc_green
        table.cell(dashboard, 3, current_row, str.tostring(lang_state.galois_rank, "#.##"), text_halign=text.align_right, text_color=galois_color, text_size=label_size)
        current_row += 1
        
        // Operadic & Correspondence
        table.cell(dashboard, 0, current_row, "Operadic", text_color=dc_gray, text_size=label_size)
        operadic_color = composite_signal > 0.3 ? dc_green : composite_signal < -0.3 ? dc_red : dc_gray
        table.cell(dashboard, 1, current_row, str.tostring(composite_signal, "#.##"), text_halign=text.align_right, text_color=operadic_color, text_size=label_size)
        table.cell(dashboard, 2, current_row, "Corr.", text_color=dc_gray, text_size=label_size)
        corr_value = 1 - lang_state.correspondence_error
        corr_color = corr_value > 0.7 ? dc_green : corr_value > 0.4 ? dc_orange : dc_red
        table.cell(dashboard, 3, current_row, str.tostring(corr_value, "#.##"), text_halign=text.align_right, text_color=corr_color, text_size=label_size)
        current_row += 1
    
    // ═══ ORDER FLOW ANALYSIS SECTION ═══
    table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
    table.cell(dashboard, 0, current_row, "═══ 📊 ORDER FLOW ANALYSIS ═══", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
    current_row += 1
    
    // OFPI Value and Visual Gauge
    ofpi_display = ofpi_value * 100
    gauge_bars = int(math.abs(ofpi_display) / 10)
    gauge_bars := math.min(gauge_bars, 10)
    gauge_str = ofpi_value > 0 ? "▰" + str.repeat("█", gauge_bars) + str.repeat("░", 10 - gauge_bars) : str.repeat("░", 10 - gauge_bars) + str.repeat("█", gauge_bars) + "▰"
    
    table.cell(dashboard, 0, current_row, "OFPI", text_color=dc_gray, text_size=label_size)
    ofpi_color = ofpi_value > 0.15 ? dc_green : ofpi_value < -0.15 ? dc_red : dc_gray
    table.cell(dashboard, 1, current_row, str.tostring(ofpi_display, "#.#") + "%", text_halign=text.align_right, text_color=ofpi_color, text_size=value_size)
    
    if dashboard_size == "Large"
        table.cell(dashboard, 2, current_row, "Flow", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 3, current_row, gauge_str, text_halign=text.align_right, text_color=ofpi_value > 0 ? dc_green : dc_red, text_size=label_size)
    else
        table.merge_cells(dashboard, 2, current_row, cols - 1, current_row)
        table.cell(dashboard, 2, current_row, gauge_str, text_halign=text.align_right, text_color=ofpi_value > 0 ? dc_green : dc_red, text_size=label_size)
    current_row += 1
    
    // Flow Momentum Status
    flow_accelerating := math.abs(ofpi_value) > math.abs(ofpi_value[1])
    momentum_status = momentum_shifting ? "🔄 SHIFTING" : flow_accelerating ? "📈 ACCELERATING" : math.abs(ofpi_value) > 0.5 ? "💪 STRONG" : math.abs(ofpi_value) > 0.2 ? "📊 MODERATE" : "😴 WEAK"
    momentum_color = momentum_shifting ? dc_gold : flow_accelerating ? dc_aqua : math.abs(ofpi_value) > 0.3 ? dc_green : dc_gray
    
    table.cell(dashboard, 0, current_row, "Momentum", text_color=dc_gray, text_size=label_size)
    table.merge_cells(dashboard, 1, current_row, cols - 1, current_row)
    table.cell(dashboard, 1, current_row, momentum_status, text_halign=text.align_right, text_color=momentum_color, text_size=value_size)
    current_row += 1
    
    // OFPI Configuration Details (Large dashboard only)
    if dashboard_size == "Large"
        table.cell(dashboard, 0, current_row, "OFPI Config", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 1, current_row, "Len:" + str.tostring(ofpi_length), text_color=dc_cyan, text_size=label_size)
        table.cell(dashboard, 2, current_row, "T3:" + str.tostring(ofpi_t3_length), text_color=dc_cyan, text_size=label_size)
        table.cell(dashboard, 3, current_row, "VF:" + str.tostring(ofpi_t3_vfactor, "#.#"), text_color=dc_cyan, text_size=label_size)
        current_row += 1
    
    // ═══ SIGNAL PERFORMANCE SECTION ═══
    table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
    table.cell(dashboard, 0, current_row, "═══ 🏆 SIGNAL PERFORMANCE ═══", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
    current_row += 1
    
    // Win Rate and Signal Count
    win_rate = total_signals > 0 ? (winning_signals / total_signals) * 100 : 0.0
    win_rate_color = win_rate >= 60 ? dc_green : win_rate >= 45 ? dc_orange : dc_red
    win_rate_emoji = win_rate >= 60 ? "🔥" : win_rate >= 45 ? "👍" : "⚠️"
    
    table.cell(dashboard, 0, current_row, "Win Rate", text_color=dc_gray, text_size=label_size)
    table.cell(dashboard, 1, current_row, win_rate_emoji + str.tostring(win_rate, "#.#") + "%", text_halign=text.align_right, text_color=win_rate_color, text_size=label_size)
    table.cell(dashboard, 2, current_row, "Signals", text_color=dc_gray, text_size=label_size)
    table.cell(dashboard, 3, current_row, str.tostring(total_signals), text_halign=text.align_right, text_color=dc_gray, text_size=label_size)
    current_row += 1
    
    // Current Position and Volatility
    table.cell(dashboard, 0, current_row, "Position", text_color=dc_gray, text_size=label_size)
    position_text = direction == 1 ? "🟢 LONG" : direction == -1 ? "🔴 SHORT" : "⚪ NONE"
    position_color = direction == 1 ? dc_green : direction == -1 ? dc_red : dc_gray
    table.cell(dashboard, 1, current_row, position_text, text_color=position_color, text_size=value_size)
    
    // Volatility Regime
    table.cell(dashboard, 2, current_row, "Vol Regime", text_color=dc_gray, text_size=label_size)
    vol_text = volatility_percentile > 70 ? "🔥 HIGH" : volatility_percentile > 30 ? "📊 MED" : "😴 LOW"
    vol_color = volatility_percentile > 70 ? dc_red : volatility_percentile > 30 ? dc_gold : dc_green
    table.cell(dashboard, 3, current_row, vol_text, text_color=vol_color, text_size=value_size)
    current_row += 1
    
    // ═══ MARKET STRUCTURE SECTION ═══ (Normal and Large only)
    if dashboard_size != "Small"
        table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
        table.cell(dashboard, 0, current_row, "═══ 🌌 MARKET STRUCTURE ═══", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
        current_row += 1
        
        // Möbius Field Strength Calculation
        mobius_field_strength_calc = 0.0
        field_oscillations = 0
        for n = 1 to math.min(20, max_mobius_n)
            mob_val = array.get(mobius_arr, n)
            price_cycle = math.sin(2 * 3.14159 * bar_index / n)
            contribution = mob_val * price_cycle * (1 / n)
            mobius_field_strength_calc += contribution
            if n > 1 and mob_val != array.get(mobius_arr, n-1)
                field_oscillations += 1
        mobius_field_strength_calc := math.abs(mobius_field_strength_calc) * field_oscillations
        
        table.cell(dashboard, 0, current_row, "Möbius Field", text_color=dc_gray, text_size=label_size)
        field_str = mobius_field_strength_calc > 2.0 ? "🌪️ CHAOTIC" : mobius_field_strength_calc > 1.0 ? "⚡ STRONG" : mobius_field_strength_calc > 0.5 ? "📊 MODERATE" : "😴 WEAK"
        field_color = mobius_field_strength_calc > 2.0 ? dc_red : mobius_field_strength_calc > 1.0 ? dc_gold : mobius_field_strength_calc > 0.5 ? dc_purple : dc_gray
        table.merge_cells(dashboard, 1, current_row, cols - 1, current_row)
        table.cell(dashboard, 1, current_row, field_str, text_halign=text.align_right, text_color=field_color, text_size=label_size)
        current_row += 1
        
        // HTF Trend and Agreement
        table.cell(dashboard, 0, current_row, "HTF Trend", text_color=dc_gray, text_size=label_size)
        htf_text = lang_state.htf_trend > 0 ? "📈 BULL" : lang_state.htf_trend < 0 ? "📉 BEAR" : "➡️ NEUTRAL"
        htf_color = lang_state.htf_trend > 0 ? dc_green : lang_state.htf_trend < 0 ? dc_red : dc_gray
        table.cell(dashboard, 1, current_row, htf_text, text_color=htf_color, text_size=label_size)
        
        table.cell(dashboard, 2, current_row, "Agreement", text_color=dc_gray, text_size=label_size)
        agreement_text = agreement_direction == 1 ? "🤝 BULL" : agreement_direction == -1 ? "🤝 BEAR" : "🤷 MIXED"
        agreement_color = agreement_direction == 1 ? dc_green : agreement_direction == -1 ? dc_red : dc_orange
        table.cell(dashboard, 3, current_row, agreement_text, text_color=agreement_color, text_size=label_size)
        current_row += 1
    
    // ═══ POSITION DETAILS SECTION ═══ (When in position)
    if direction != 0 and dashboard_size != "Small"
        table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
        table.cell(dashboard, 0, current_row, "═══ 💼 POSITION DETAILS ═══", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
        current_row += 1
        
        // Entry Price and Current P&L
        table.cell(dashboard, 0, current_row, "Entry", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 1, current_row, str.tostring(entry_price, "#.##"), text_halign=text.align_right, text_color=dc_white, text_size=label_size)
        
        pnl = direction == 1 ? ((close - entry_price) / entry_price) * 100 : ((entry_price - close) / entry_price) * 100
        pnl_emoji = pnl > 2 ? "🚀" : pnl > 0 ? "💚" : pnl > -2 ? "⚠️" : "🔴"
        table.cell(dashboard, 2, current_row, "P&L", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 3, current_row, pnl_emoji + str.tostring(pnl, "#.##") + "%", text_halign=text.align_right, text_color=pnl > 0 ? dc_green : dc_red, text_size=label_size)
        current_row += 1
        
        // Position Risk and Duration
        if dashboard_size == "Large"
            table.cell(dashboard, 0, current_row, "Risk Level", text_color=dc_gray, text_size=label_size)
            risk_level = math.abs(pnl) > 5 ? "🔥 HIGH" : math.abs(pnl) > 2 ? "⚠️ MED" : "✅ LOW"
            risk_color = math.abs(pnl) > 5 ? dc_red : math.abs(pnl) > 2 ? dc_orange : dc_green
            table.cell(dashboard, 1, current_row, risk_level, text_color=risk_color, text_size=label_size)
            
            bars_in_trade = bar_index - last_signal_bar
            table.cell(dashboard, 2, current_row, "Duration", text_color=dc_gray, text_size=label_size)
            table.cell(dashboard, 3, current_row, str.tostring(bars_in_trade) + " bars", text_color=dc_aqua, text_size=label_size)
            current_row += 1
    
    // ═══ SETTINGS SUMMARY ═══ (Large dashboard only)
    if dashboard_size == "Large"
        table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
        table.cell(dashboard, 0, current_row, "═══ ⚙️ ACTIVE SETTINGS ═══", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
        current_row += 1
        
        // Key parameter summary
        table.cell(dashboard, 0, current_row, "Threshold", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 1, current_row, str.tostring(score_threshold, "#.#"), text_color=dc_cyan, text_size=label_size)
        table.cell(dashboard, 2, current_row, "Arity", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 3, current_row, str.tostring(composition_arity), text_color=dc_cyan, text_size=label_size)
        current_row += 1
        
        table.cell(dashboard, 0, current_row, "Agreement", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 1, current_row, str.tostring(agreement_required), text_color=dc_cyan, text_size=label_size)
        table.cell(dashboard, 2, current_row, "Theme", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 3, current_row, visual_theme, text_color=dc_purple, text_size=label_size)
        current_row += 1
//==============================================================================
// ANIMATED WATERMARK
//==============================================================================
var table watermarkMain = table.new(position.bottom_center, 3, 1, bgcolor=color.new(color.black, 100), border_width=0)
var table watermarkGlow1 = table.new(position.bottom_center, 3, 1, bgcolor=color.new(color.black, 100), border_width=0)
var table watermarkGlow2 = table.new(position.bottom_center, 3, 1, bgcolor=color.new(color.black, 100), border_width=0)

var int animFrame = 0
var float glowAlphaWatermark = 80 

if barstate.isrealtime
    animFrame := (animFrame + 1) % 100
    glowAlphaWatermark := 70 + math.sin(animFrame * 0.1) * 20  
    
    table.clear(watermarkMain, 0, 0)
    table.clear(watermarkGlow1, 0, 0)
    table.clear(watermarkGlow2, 0, 0)
    
    watermark_text_size = dashboard_size == "Large" ? size.normal : dashboard_size == "Normal" ? size.small : size.tiny
    
    watermarkColorBase = total_score_display > 0 ? color.rgb(100, 255, 100) : total_score_display < 0 ? color.rgb(255, 100, 100) : c1
    accent1 = c2
    
    table.cell(watermarkGlow2, 0, 0, "⚡", text_color=color.new(watermarkColorBase, math.round(glowAlphaWatermark) + 20), text_size=watermark_text_size, text_halign=text.align_center)
    table.cell(watermarkGlow2, 1, 0, "Dskyz (DAFE) Quant Systems", text_color=color.new(watermarkColorBase, math.round(glowAlphaWatermark) + 20), text_size=watermark_text_size, text_halign=text.align_center)
    table.cell(watermarkGlow2, 2, 0, "⚡", text_color=color.new(watermarkColorBase, math.round(glowAlphaWatermark) + 20), text_size=watermark_text_size, text_halign=text.align_center)

    table.cell(watermarkGlow1, 0, 0, "⚡", text_color=color.new(accent1, math.round(glowAlphaWatermark)), text_size=watermark_text_size, text_halign=text.align_center) 
    table.cell(watermarkGlow1, 1, 0, "Dskyz (DAFE) Quant Systems", text_color=color.new(accent1, math.round(glowAlphaWatermark)), text_size=watermark_text_size, text_halign=text.align_center)
    table.cell(watermarkGlow1, 2, 0, "⚡", text_color=color.new(accent1, math.round(glowAlphaWatermark)), text_size=watermark_text_size, text_halign=text.align_center)

    mainTextWatermark = "Dskyz (DAFE) Quant Systems"
    table.cell(watermarkMain, 0, 0, animFrame % 20 < 10 ? "⚡" : "✦", text_color=watermarkColorBase, text_size=watermark_text_size, text_halign=text.align_center)
    table.cell(watermarkMain, 1, 0, mainTextWatermark, text_color=watermarkColorBase, text_size=watermark_text_size, text_halign=text.align_center)
    table.cell(watermarkMain, 2, 0, animFrame % 20 >= 10 ? "⚡" : "✦", text_color=watermarkColorBase, text_size=watermark_text_size, text_halign=text.align_center)


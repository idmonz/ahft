Anomalous Holonomy Field Theory


ğŸŒŒ Anomalous Holonomy Field Theory (AHFT) - Revolutionary Quantum Market Analysis
Where Theoretical Physics Meets Trading Reality
A Groundbreaking Synthesis of Differential Geometry, Quantum Field Theory, and Market Dynamics


ğŸ”¬ THEORETICAL FOUNDATION - THE MATHEMATICS OF MARKET REALITY
The Anomalous Holonomy Field Theory represents an unprecedented fusion of advanced mathematical physics with practical market analysis. This isn't merely another indicator repackaging old concepts - it's a fundamentally new lens through which to view and understand market structure.
1. HOLONOMY GROUPS (Differential Geometry)
In differential geometry, holonomy measures how vectors change when parallel transported around closed loops in curved space. Applied to markets:
Mathematical Formula:
H = P exp(âˆ®_C A_Î¼ dx^Î¼)
Where:


P = Path ordering operator
A_Î¼ = Market connection (price-volume gauge field)
C = Closed price path


Market Implementation:
The holonomy calculation measures how price "remembers" its journey through market space. When price returns to a previous level, the holonomy captures what has changed in the market's internal geometry. This reveals:


Hidden curvature in the market manifold
Topological obstructions to arbitrage
Geometric phase accumulated during price cycles


2. ANOMALY DETECTION (Quantum Field Theory)
Drawing from the Adler-Bell-Jackiw anomaly in quantum field theory:
Mathematical Formula:
âˆ‚_Î¼ j^Î¼ = (eÂ²/16Ï€Â²)F_Î¼Î½ FÌƒ^Î¼Î½
Where:


j^Î¼ = Market current (order flow)
F_Î¼Î½ = Field strength tensor (volatility structure)
FÌƒ^Î¼Î½ = Dual field strength


Market Application:
Anomalies represent symmetry breaking in market structure - moments when normal patterns fail and extraordinary opportunities arise. The system detects:


Spontaneous symmetry breaking (trend reversals)
Vacuum fluctuations (volatility clusters)
Non-perturbative effects (market crashes/melt-ups)


3. GAUGE THEORY (Theoretical Physics)
Markets exhibit gauge invariance - the fundamental physics remains unchanged under certain transformations:
Mathematical Formula:
A'_Î¼ = A_Î¼ + âˆ‚_Î¼Î›
This ensures our signals are gauge-invariant observables, immune to arbitrary market "coordinate changes" like gaps or reference point shifts.
4. TOPOLOGICAL DATA ANALYSIS
Using persistent homology and Morse theory:
Mathematical Formula:
Î²_k = dim(H_k(X))
Where Î²_k are the Betti numbers describing topological features that persist across scales.


ğŸ¯ REVOLUTIONARY SIGNAL CONFIGURATION
Signal Sensitivity (0.5-12.0, default 2.5)
Controls the responsiveness of holonomy field calculations to market conditions. This parameter directly affects the threshold for detecting quantum phase transitions in price action.
Optimization by Timeframe:


Scalping (1-5min): 1.5-3.0 for rapid signal generation
Day Trading (15min-1H): 2.5-5.0 for balanced sensitivity
Swing Trading (4H-1D): 5.0-8.0 for high-quality signals only


Score Amplifier (10-200, default 50)
Scales the raw holonomy field strength to produce meaningful signal values. Higher values amplify weak signals in low-volatility environments.
Signal Confirmation Toggle
When enabled, enforces additional technical filters (EMA and RSI alignment) to reduce false positives. Essential for conservative strategies.
Minimum Bars Between Signals (1-20, default 5)
Prevents overtrading by enforcing quantum decoherence time between signals. Higher values reduce whipsaws in choppy markets.


ğŸ‘‘ ELITE EXECUTION SYSTEM
Execution Modes:
Conservative Mode:


Stricter signal criteria
Higher quality thresholds
Ideal for stable market conditions


Adaptive Mode:


Self-adjusting parameters
Balances signal frequency with quality
Recommended for most traders


Aggressive Mode:


Maximum signal sensitivity
Captures rapid market moves
Best for experienced traders in volatile conditions


Dynamic Position Sizing:
When enabled, the system scales position size based on:


Holonomy field strength
Current volatility regime
Recent performance metrics


Advanced Exit Management:
Implements trailing stops based on ATR and signal strength, with mode-specific multipliers for optimal profit capture.


ğŸ§  ADAPTIVE INTELLIGENCE ENGINE
Self-Learning System:
The strategy analyzes recent trade outcomes and adjusts:


Risk multipliers based on win/loss ratios
Signal weights according to performance
Market regime detection for environmental adaptation


Learning Speed (0.05-0.3):
Controls adaptation rate. Higher values = faster learning but potentially unstable. Lower values = stable but slower adaptation.
Performance Window (20-100 trades):
Number of recent trades analyzed for adaptation. Longer windows provide stability, shorter windows increase responsiveness.


ğŸ¨ REVOLUTIONARY VISUAL SYSTEM
1. Holonomy Field Visualization
What it shows: Multi-layer quantum field bands representing market resonance zones
How to interpret:


Blue/Purple bands = Primary holonomy field (strongest resonance)
Band width = Field strength and volatility
Price within bands = Normal quantum state
Price breaking bands = Quantum phase transition


Trading application: Trade reversals at band extremes, breakouts on band violations with strong signals.
2. Quantum Portals
What they show: Entry signals with recursive depth patterns indicating momentum strength
How to interpret:


Upward triangles with portals = Long entry signals
Downward triangles with portals = Short entry signals
Portal depth = Signal strength and expected momentum
Color intensity = Probability of success


Trading application: Enter on portal appearance, with size proportional to portal depth.
3. Field Resonance Bands
What they show: Fibonacci-based harmonic price zones where quantum resonance occurs
How to interpret:


Dotted circles = Minor resonance levels
Solid circles = Major resonance levels
Color coding = Resonance strength


Trading application: Use as dynamic support/resistance, expect reactions at resonance zones.
4. Anomaly Detection Grid
What it shows: Fractal-based support/resistance with anomaly strength calculations
How to interpret:


Triple-layer lines = Major fractal levels with high anomaly probability
Labels show: Period (H8-H55), Price, and Anomaly strength (Ï†)
âš¡ symbol = Extreme anomaly detected
â— symbol = Strong anomaly
â—‹ symbol = Normal conditions


Trading application: Expect major moves when price approaches high anomaly levels. Use for precise entry/exit timing.
5. Phase Space Flow
What it shows: Background heatmap revealing market topology and energy
How to interpret:


Dark background = Low market energy, range-bound
Purple glow = Building energy, trend developing
Bright intensity = High energy, strong directional move


Trading application: Trade aggressively in bright phases, reduce activity in dark phases.


ğŸ“Š PROFESSIONAL DASHBOARD METRICS
Holonomy Field Strength (-100 to +100)
What it measures: The Wilson loop integral around price paths


>70: Strong positive curvature (bullish vortex)
<-70: Strong negative curvature (bearish collapse)
Near 0: Flat connection (range-bound)


Anomaly Level (0-100%)
What it measures: Quantum vacuum expectation deviation


>70%: Major anomaly (phase transition imminent)
30-70%: Moderate anomaly (elevated volatility)
<30%: Normal quantum fluctuations


Quantum State (-1, 0, +1)
What it measures: Market wave function collapse


+1: Bullish eigenstate |â†‘âŸ©
0: Superposition (uncertain)
-1: Bearish eigenstate |â†“âŸ©


Signal Quality Ratings


LEGENDARY: All quantum fields aligned, maximum probability
EXCEPTIONAL: Strong holonomy with anomaly confirmation
STRONG: Good field strength, moderate anomaly
MODERATE: Decent signals, some uncertainty
WEAK: Minimal edge, high quantum noise


Performance Metrics


Win Rate: Rolling performance with emoji indicators
Daily P&L: Real-time profit tracking
Adaptive Risk: Current risk multiplier status
Market Regime: Bull/Bear classification




ğŸ† WHY THIS CHANGES EVERYTHING
Traditional technical analysis operates on 100-year-old principles - moving averages, support/resistance, and pattern recognition. These work because many traders use them, creating self-fulfilling prophecies.
AHFT transcends this limitation by analyzing markets through the lens of fundamental physics:


Markets have geometry - The holonomy calculations reveal this hidden structure
Price has memory - The geometric phase captures path-dependent effects
Anomalies are predictable - Quantum field theory identifies symmetry breaking
Everything is connected - Gauge theory unifies disparate market phenomena


This isn't just a new indicator - it's a new way of thinking about markets. Just as Einstein's relativity revolutionized physics beyond Newton's mechanics, AHFT revolutionizes technical analysis beyond traditional methods.


ğŸ”§ OPTIMAL SETTINGS FOR MNQ 10-MINUTE
For the Micro E-mini Nasdaq-100 on 10-minute timeframe:


Signal Sensitivity: 2.5-3.5
Score Amplifier: 50-70
Execution Mode: Adaptive
Min Bars Between: 3-5
Theme: Quantum Nebula or Dark Matter




ğŸ’­ THE JOURNEY - FROM IMPOSSIBLE THEORY TO TRADING REALITY
Creating AHFT was a mathematical odyssey that pushed the boundaries of what's possible in Pine Script. The journey began with a seemingly impossible question: Could the profound mathematical structures of theoretical physics be translated into practical trading tools?
The Theoretical Challenge:
Months were spent diving deep into differential geometry textbooks, studying the works of Chern, Simons, and Witten. The mathematics of holonomy groups and gauge theory had never been applied to financial markets. Translating abstract mathematical concepts like parallel transport and fiber bundles into discrete price calculations required novel approaches and countless failed attempts.
The Computational Nightmare:
Pine Script wasn't designed for quantum field theory calculations. Implementing the Wilson loop integral, managing complex array structures for anomaly detection, and maintaining computational efficiency while calculating geometric phases pushed the language to its limits. There were moments when the entire project seemed impossible - the script would timeout, produce nonsensical results, or simply refuse to compile.
The Breakthrough Moments:
After countless sleepless nights and thousands of lines of code, breakthrough came through elegant simplifications. The realization that market anomalies follow patterns similar to quantum vacuum fluctuations led to the revolutionary anomaly detection system. The discovery that price paths exhibit holonomic memory unlocked the geometric phase calculations.
The Visual Revolution:
Creating visualizations that could represent 4-dimensional quantum fields on a 2D chart required innovative approaches. The multi-layer holonomy field, recursive quantum portals, and phase space flow representations went through dozens of iterations before achieving the perfect balance of beauty and functionality.
The Balancing Act:
Perhaps the greatest challenge was maintaining mathematical rigor while ensuring practical trading utility. Every formula had to be both theoretically sound and computationally efficient. Every visual had to be both aesthetically pleasing and information-rich.
The result is more than a strategy - it's a synthesis of pure mathematics and market reality that reveals the hidden order within apparent chaos.


ğŸ“š INTEGRATED DOCUMENTATION
Once applied to your chart, AHFT includes comprehensive tooltips on every input parameter. The source code contains detailed explanations of the mathematical theory, practical applications, and optimization guidelines. This published description provides the overview - the indicator itself is a complete educational resource.


âš ï¸ RISK DISCLAIMER
While AHFT employs advanced mathematical models derived from theoretical physics, markets remain inherently unpredictable. No mathematical model, regardless of sophistication, can guarantee future results. This strategy uses realistic commission ($0.62 per contract) and slippage (1 tick) in all calculations. Past performance does not guarantee future results. Always use appropriate risk management and never risk more than you can afford to lose.


ğŸŒŸ CONCLUSION
The Anomalous Holonomy Field Theory represents a quantum leap in technical analysis - literally. By applying the profound insights of differential geometry, quantum field theory, and gauge theory to market analysis, AHFT reveals structure and opportunities invisible to traditional methods.
From the holonomy calculations that capture market memory to the anomaly detection that identifies phase transitions, from the adaptive intelligence that learns and evolves to the stunning visualizations that make the invisible visible, every component works in mathematical harmony.
This is more than a trading strategy. It's a new lens through which to view market reality.
Trade with the precision of physics. Trade with the power of mathematics. Trade with AHFT.


I hope this serves as a good replacement for Quantum Edge Pro - Adaptive AI until I'm able to fix it.


â€” Dskyz, Trade with insight. Trade with anticipation.

//@version=5
strategy("Anomalous Holonomy Field Theory", shorttitle="ğŸŒŒ AHFT", overlay=true, initial_capital=100000, default_qty_type=strategy.fixed, default_qty_value=1, commission_type=strategy.commission.cash_per_contract, commission_value=0.62, slippage=1, calc_on_every_tick=false, process_orders_on_close=false, max_bars_back=1000)

//==============================================================================
// ğŸ“š COMPREHENSIVE USER GUIDE & MATHEMATICAL THEORY
//==============================================================================// 
// ğŸŒŒ ANOMALOUS HOLONOMY FIELD THEORY - THE ULTIMATE TRADING SYSTEM
// 
// Welcome to the most advanced mathematical trading algorithm ever created,
// combining cutting-edge theories from theoretical physics, differential geometry,
// algebraic topology, and quantum field theory.
//
// âš¡ WHAT MAKES THIS REVOLUTIONARY:
// 
// Traditional indicators use simple calculations like moving averages or RSI.
// This system analyzes markets through the lens of:
//
// 1. HOLONOMY GROUPS (Differential Geometry):
//    - Measures how price "parallel transports" around closed loops
//    - Detects hidden curvature in the market manifold
//    - Identifies topological obstructions to arbitrage
//
// 2. ANOMALY DETECTION (Quantum Field Theory):
//    - Models price as a quantum field with anomalous symmetries
//    - Detects spontaneous symmetry breaking (trend changes)
//    - Identifies vacuum fluctuations (volatility clusters)
//
// 3. GAUGE THEORY (Theoretical Physics):
//    - Markets as gauge fields with local symmetries
//    - Price action as covariant derivatives
//    - Momentum as gauge connection components
//
// 4. TOPOLOGICAL DATA ANALYSIS:
//    - Persistent homology of price formations
//    - Betti numbers for market structure
//    - Morse theory for critical points
//
// ğŸ¯ DASHBOARD METRICS DEEP DIVE:
//
// ğŸ“Š HOLONOMY FIELD STRENGTH (-100 to +100):
// Mathematical Formula: H = âˆ®_C AÂ·dx where A is the market connection
// â€¢ Measures the Wilson loop integral around price paths
// â€¢ >70: Strong positive curvature (bullish vortex forming)
// â€¢ <-70: Strong negative curvature (bearish collapse)
// â€¢ Near 0: Flat connection (range-bound, no directional bias)
// â€¢ Based on parallel transport in fiber bundles
//
// ğŸŒ€ ANOMALY LEVEL (0-100%):
// Mathematical Formula: A = |âŸ¨0|Ï†(x)|0âŸ© - âŸ¨0|Ï†(x)|0âŸ©_classical|
// â€¢ Quantum vacuum expectation deviation
// â€¢ >70%: Major anomaly (phase transition imminent)
// â€¢ 30-70%: Moderate anomaly (heightened volatility)
// â€¢ <30%: Normal quantum fluctuations
// â€¢ Detects non-perturbative effects in price action
//
// âš¡ QUANTUM STATE (-1, 0, +1):
// Mathematical Formula: |ÏˆâŸ© = Î±|â†‘âŸ© + Î²|â†“âŸ©, measure in Ïƒ_z basis
// â€¢ +1: Collapsed to bullish eigenstate |â†‘âŸ©
// â€¢ 0: Superposition state (uncertain)
// â€¢ -1: Collapsed to bearish eigenstate |â†“âŸ©
// â€¢ Based on quantum measurement theory
//
// ğŸ”® SIGNAL QUALITY RATINGS:
// â€¢ LEGENDARY: All quantum fields aligned, anomaly confirmed
// â€¢ EXCEPTIONAL: Strong holonomy, high anomaly correlation  
// â€¢ STRONG: Good field strength, moderate anomaly
// â€¢ MODERATE: Decent signals, some uncertainty
// â€¢ WEAK: Minimal edge, high quantum noise
//
// ğŸ§® THE MATHEMATICS IN DETAIL:
//
// HOLONOMY CALCULATION:
// The holonomy group element g âˆˆ G is computed as:
// g = P exp(âˆ®_C A_Î¼ dx^Î¼)
// Where P denotes path ordering and A_Î¼ is the gauge connection.
// In discrete form: g_n = âˆáµ¢ exp(iA_iÂ·Î”x_i)
//
// ANOMALY DETECTION:
// Uses the Adler-Bell-Jackiw anomaly equation:
// âˆ‚_Î¼ j^Î¼ = (eÂ²/16Ï€Â²)F_Î¼Î½ FÌƒ^Î¼Î½
// Where FÌƒ^Î¼Î½ is the dual field strength tensor.
//
// QUANTUM FIELD OPERATOR:
// Price modeled as quantum field Ï†(x,t) with action:
// S[Ï†] = âˆ«dâ´x [Â½(âˆ‚_Î¼Ï†)Â² - V(Ï†)]
// Vacuum fluctuations: âŸ¨0|Ï†Â²|0âŸ© = âˆ« dÂ³k/(2Ï€)Â³ Â· 1/(2Ï‰_k)
//
// GAUGE TRANSFORMATION:
// Market invariance under: A'_Î¼ = A_Î¼ + âˆ‚_Î¼Î›
// Ensures gauge-invariant observables for robust signals.
//
// ğŸ’¡ TRADING PHILOSOPHY:
// 
// Markets are not random walks but complex quantum systems with:
// â€¢ Hidden symmetries (profit opportunities)
// â€¢ Topological constraints (support/resistance)
// â€¢ Anomalous behaviors (breakouts/crashes)
// â€¢ Holonomic memory (price has geometric phase)
//
// By detecting these deep mathematical structures, we can predict
// phase transitions and capture profits from quantum fluctuations.
//
// ğŸ¯ HOW TO USE THIS SYSTEM:
//
// 1. SIGNAL IDENTIFICATION:
//    - Wait for Holonomy Field Strength to exceed thresholds
//    - Confirm with Anomaly Level >30%
//    - Check Quantum State alignment
//    - Verify visual portal activation
//
// 2. ENTRY EXECUTION:
//    - Use Quantum Portals for precise entry
//    - Size positions based on field strength
//    - Set stops at holonomic support/resistance
//
// 3. EXIT MANAGEMENT:
//    - Monitor anomaly decay
//    - Watch for quantum state flips
//    - Use trailing stops in strong trends
//
// 4. RISK CONTROL:
//    - Never trade against strong holonomy
//    - Reduce size in low anomaly environments
//    - Respect quantum uncertainty limits
//
// âš ï¸ ADVANCED RISK WARNING:
// While mathematically sophisticated, markets can exhibit:
// â€¢ Quantum decoherence (signal degradation)
// â€¢ Non-local correlations (contagion effects)
// â€¢ Measurement collapse (observation changes outcome)
// Always use proper position sizing and risk management.
//
// ==============================================================================
// ğŸ¯ SIGNAL CONFIGURATION
// ==============================================================================
group_signals = "ğŸ¯ Signal Configuration"
SIGNAL_SENSITIVITY = input.float(2.5, "âš™ï¸ Signal Sensitivity", minval=0.5, maxval=12.0, step=0.1, group=group_signals,
  tooltip="ğŸ¯ WHAT IT IS: Controls the responsiveness of signal generation to market conditions\n\n" +
  "âš¡ HOW IT WORKS: Adjusts the threshold for triggering buy/sell signals based on holonomy field strength\n\n" +
  "ğŸ“ˆ HIGHER VALUES (6.0-12.0): Fewer signals, higher quality, less noise\n" +
  "ğŸ“‰ LOWER VALUES (0.5-3.0): More signals, more sensitive, higher noise\n\n" +
  "ğŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping (1-5min): 1.5-3.0 (fast signals)\n" +
  "â€¢ Day Trading (15min-1H): 2.5-5.0 (balanced)\n" +
  "â€¢ Swing Trading (4H-1D): 5.0-8.0 (high quality)\n\n" +
  "ğŸ¦ SECTOR RECOMMENDATIONS:\n" +
  "â€¢ Stocks: 3.0-5.0 (stable signals)\n" +
  "â€¢ Crypto: 1.5-3.5 (volatile markets)\n" +
  "â€¢ Forex: 4.0-6.0 (smooth trends)\n" +
  "â€¢ Indices: 3.5-5.5 (trending markets)\n\n" +
  "ğŸ’¡ PRO TIP: Start with 2.5 and adjust based on backtesting for your market and timeframe")
SCORE_AMPLIFIER = input.float(50.0, "ğŸ”Š Score Amplifier", minval=10.0, maxval=200.0, step=5.0, group=group_signals,
  tooltip="ğŸ¯ WHAT IT IS: Scales the raw holonomy field strength to produce meaningful signal values\n\n" +
  "âš¡ HOW IT WORKS: Multiplies the calculated signal score to align with the -10 to +10 range\n\n" +
  "ğŸ“ˆ HIGHER VALUES (100-200): Amplify signals for clearer differentiation, useful in low-volatility markets\n" +
  "ğŸ“‰ LOWER VALUES (10-50): Reduce amplification for more conservative signals, better in high-volatility markets\n\n" +
  "ğŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping: 30-70 (faster signals)\n" +
  "â€¢ Day Trading: 50-100 (balanced amplification)\n" +
  "â€¢ Swing Trading: 80-150 (stronger signals)\n\n" +
  "ğŸ¦ SECTOR RECOMMENDATIONS:\n" +
  "â€¢ Crypto: 30-70 (volatile, needs sensitivity)\n" +
  "â€¢ Stocks: 50-100 (balanced)\n" +
  "â€¢ Forex: 80-120 (smooth trends)\n" +
  "â€¢ Indices: 70-110 (trending markets)\n\n" +
  "ğŸ’¡ PRO TIP: Adjust to ensure signals align with your risk tolerance and market conditions")
SIGNAL_CONFIRMATION = input.bool(true, "âœ… Require Signal Confirmation", group=group_signals,
  tooltip="ğŸ¯ WHAT IT IS: Enforces additional technical filters for signal validation\n\n" +
  "âš¡ HOW IT WORKS: Requires signals to align with EMA and RSI conditions to reduce false positives\n\n" +
  "ğŸ“ˆ ENABLED: Higher quality signals, fewer trades, ideal for conservative strategies\n" +
  "ğŸ“‰ DISABLED: More signals, potentially noisier, suitable for aggressive strategies\n\n" +
  "ğŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping: Disable for faster entries\n" +
  "â€¢ Day Trading: Enable for balanced reliability\n" +
  "â€¢ Swing Trading: Enable for high-confidence trades\n\n" +
  "ğŸ¦ SECTOR RECOMMENDATIONS:\n" +
  "â€¢ Stocks: Enable (stable markets benefit from confirmation)\n" +
  "â€¢ Crypto: Disable or Enable (depends on volatility tolerance)\n" +
  "â€¢ Forex: Enable (smooth trends)\n" +
  "â€¢ Indices: Enable (trending markets)\n\n" +
  "ğŸ’¡ PRO TIP: Enable for higher win rates, disable for higher trade frequency")
MIN_SIGNAL_SEPARATION = input.int(5, "â³ Minimum Bars Between Signals", minval=1, maxval=20, group=group_signals,
  tooltip="ğŸ¯ WHAT IT IS: Minimum number of bars required between consecutive signals\n\n" +
  "âš¡ HOW IT WORKS: Prevents over-trading by enforcing a cooldown period between signals\n\n" +
  "ğŸ“ˆ HIGHER VALUES (10-20): Fewer signals, reduces whipsaws in choppy markets\n" +
  "ğŸ“‰ LOWER VALUES (1-5): More frequent signals, captures rapid market moves\n\n" +
  "ğŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping (1-5min): 1-3 bars (fast-paced trading)\n" +
  "â€¢ Day Trading (15min-1H): 3-7 bars (balanced)\n" +
  "â€¢ Swing Trading (4H-1D): 7-15 bars (longer-term focus)\n\n" +
  "ğŸ¦ SECTOR RECOMMENDATIONS:\n" +
  "â€¢ Crypto: 1-5 (high volatility)\n" +
  "â€¢ Stocks: 5-10 (stable markets)\n" +
  "â€¢ Forex: 7-12 (trend-focused)\n" +
  "â€¢ Indices: 5-10 (trending markets)\n\n" +
  "ğŸ’¡ PRO TIP: Use higher values in low-volatility markets to avoid false signals")
// ==============================================================================
// ğŸ‘‘ ELITE EXECUTION SETTINGS
// ==============================================================================
group_execution = "ğŸ‘‘ Elite Execution"
EXECUTION_MODE = input.string("Adaptive", "âš™ï¸ Execution Mode", options=["Conservative", "Adaptive", "Aggressive"], group=group_execution,
  tooltip="ğŸ¯ WHAT IT IS: Determines the aggressiveness of trade execution and risk parameters\n\n" +
  "âš¡ HOW IT WORKS: Adjusts signal thresholds, position sizing, and exit strategies\n\n" +
  "ğŸ“ˆ CONSERVATIVE: Fewer trades, stricter criteria, lower risk, ideal for stable markets\n" +
  "ğŸ“Š ADAPTIVE: Balances frequency and quality, adjusts to market conditions\n" +
  "ğŸ“‰ AGGRESSIVE: More trades, looser criteria, higher risk, suited for volatile markets\n\n" +
  "ğŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping: Aggressive (capture quick moves)\n" +
  "â€¢ Day Trading: Adaptive (balance speed and reliability)\n" +
  "â€¢ Swing Trading: Conservative (focus on high-probability setups)\n\n" +
  "ğŸ¦ SECTOR RECOMMENDATIONS:\n" +
  "â€¢ Stocks: Conservative or Adaptive (stable markets)\n" +
  "â€¢ Crypto: Aggressive (high volatility)\n" +
  "â€¢ Forex: Adaptive or Conservative (smooth trends)\n" +
  "â€¢ Indices: Adaptive (trending markets)\n\n" +
  "ğŸ’¡ PRO TIP: Use Adaptive for most scenarios, switch to Aggressive in high-volatility breakouts")
DYNAMIC_SIZING = input.bool(true, "ğŸ“ Dynamic Position Sizing", group=group_execution,
  tooltip="ğŸ¯ WHAT IT IS: Adjusts position size based on signal strength and market conditions\n\n" +
  "âš¡ HOW IT WORKS: Scales position size using holonomy score, volatility, and performance metrics\n\n" +
  "ğŸ“ˆ ENABLED: Optimizes risk-reward by increasing size for stronger signals\n" +
  "ğŸ“‰ DISABLED: Uses fixed position size based on base risk, more predictable\n\n" +
  "ğŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping: Enable (rapid market changes)\n" +
  "â€¢ Day Trading: Enable (dynamic markets)\n" +
  "â€¢ Swing Trading: Enable or Disable (depends on risk preference)\n\n" +
  "ğŸ¦ SECTOR RECOMMENDATIONS:\n" +
  "â€¢ Crypto: Enable (volatile, benefits from dynamic sizing)\n" +
  "â€¢ Stocks: Enable (adapts to signal strength)\n" +
  "â€¢ Forex: Enable or Disable (stable trends may not need it)\n" +
  "â€¢ Indices: Enable (trending markets)\n\n" +
  "ğŸ’¡ PRO TIP: Enable for better risk management, disable for consistent position sizes")
SMART_ENTRIES = input.bool(true, "ğŸšª Smart Entry Timing", group=group_execution,
  tooltip="ğŸ¯ WHAT IT IS: Enforces timing rules to optimize trade entry points\n\n" +
  "âš¡ HOW IT WORKS: Uses minimum signal separation and market regime filters to time entries\n\n" +
  "ğŸ“ˆ ENABLED: Reduces premature entries, improves win rate in trending markets\n" +
  "ğŸ“‰ DISABLED: Allows faster entries, may increase false positives\n\n" +
  "ğŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping: Disable (need speed)\n" +
  "â€¢ Day Trading: Enable (balanced timing)\n" +
  "â€¢ Swing Trading: Enable (high-probability entries)\n\n" +
  "ğŸ¦ SECTOR RECOMMENDATIONS:\n" +
  "â€¢ Stocks: Enable (stable markets)\n" +
  "â€¢ Crypto: Disable or Enable (depends on strategy)\n" +
  "â€¢ Forex: Enable (smooth trends)\n" +
  "â€¢ Indices: Enable (trending markets)\n\n" +
  "ğŸ’¡ PRO TIP: Enable to avoid over-trading in choppy markets")
ADVANCED_EXITS = input.bool(true, "ğŸš¶ Advanced Exit Management", group=group_execution,
  tooltip="ğŸ¯ WHAT IT IS: Uses trailing stops and dynamic take-profit levels for trade exits\n\n" +
  "âš¡ HOW IT WORKS: Implements trailing stops based on ATR and signal strength for optimized exits\n\n" +
  "ğŸ“ˆ ENABLED: Maximizes profits in trending markets, reduces losses in reversals\n" +
  "ğŸ“‰ DISABLED: Uses fixed stop-loss and take-profit, simpler but less adaptive\n\n" +
  "ğŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping: Disable (quick exits needed)\n" +
  "â€¢ Day Trading: Enable (capture trends)\n" +
  "â€¢ Swing Trading: Enable (maximize profits)\n\n" +
  "ğŸ¦ SECTOR RECOMMENDATIONS:\n" +
  "â€¢ Crypto: Enable (volatile markets)\n" +
  "â€¢ Stocks: Enable (trend capture)\n" +
  "â€¢ Forex: Enable (smooth trends)\n" +
  "â€¢ Indices: Enable (trending markets)\n\n" +
  "ğŸ’¡ PRO TIP: Enable for trending markets, disable for range-bound conditions")
// ==============================================================================
// ğŸ§  ADAPTIVE INTELLIGENCE
// ==============================================================================
group_adaptive = "ğŸ§  Adaptive Intelligence"
ENABLE_LEARNING = input.bool(true, "ğŸ§  Enable Adaptive Learning", group=group_adaptive,
  tooltip="ğŸ¯ WHAT IT IS: Activates dynamic adjustment of risk based on trade performance\n\n" +
  "âš¡ HOW IT WORKS: Analyzes recent trade outcomes to adjust position sizing and risk\n\n" +
  "ğŸ“ˆ ENABLED: Adapts to market conditions, improves performance over time\n" +
  "ğŸ“‰ DISABLED: Uses static risk parameters, more predictable but less adaptive\n\n" +
  "ğŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping: Disable (rapid trades, less time to adapt)\n" +
  "â€¢ Day Trading: Enable (adapts to intraday shifts)\n" +
  "â€¢ Swing Trading: Enable (longer-term optimization)\n\n" +
  "ğŸ¦ SECTOR RECOMMENDATIONS:\n" +
  "â€¢ Crypto: Enable (volatile, benefits from adaptation)\n" +
  "â€¢ Stocks: Enable (adapts to market regimes)\n" +
  "â€¢ Forex: Enable or Disable (stable trends may not need it)\n" +
  "â€¢ Indices: Enable (trending markets)\n\n" +
  "ğŸ’¡ PRO TIP: Enable for long-term performance optimization, disable for short-term consistency")
LEARNING_SPEED = input.float(0.15, "âš¡ Learning Speed", minval=0.05, maxval=0.3, step=0.05, group=group_adaptive,
  tooltip="ğŸ¯ WHAT IT IS: Controls how quickly the system adjusts risk based on performance\n\n" +
  "âš¡ HOW IT WORKS: Determines the rate of change for the adaptive risk multiplier\n\n" +
  "ğŸ“ˆ HIGHER VALUES (0.2-0.3): Faster adaptation, more responsive to recent performance\n" +
  "ğŸ“‰ LOWER VALUES (0.05-0.1): Slower adaptation, more stable risk adjustments\n\n" +
  "ğŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping: 0.2-0.3 (quick adjustments)\n" +
  "â€¢ Day Trading: 0.15-0.25 (balanced)\n" +
  "â€¢ Swing Trading: 0.05-0.15 (stable adjustments)\n\n" +
  "ğŸ¦ SECTOR RECOMMENDATIONS:\n" +
  "â€¢ Crypto: 0.2-0.3 (volatile markets)\n" +
  "â€¢ Stocks: 0.1-0.2 (stable markets)\n" +
  "â€¢ Forex: 0.1-0.15 (smooth trends)\n" +
  "â€¢ Indices: 0.15-0.25 (trending markets)\n\n" +
  "ğŸ’¡ PRO TIP: Use higher values in volatile markets, lower values for consistent performance")
PERFORMANCE_TRACKING = input.int(50, "ğŸ“ˆ Performance Window", minval=20, maxval=100, group=group_adaptive,
  tooltip="ğŸ¯ WHAT IT IS: Number of recent trades used for adaptive learning analysis\n\n" +
  "âš¡ HOW IT WORKS: Tracks trade performance over the specified window to adjust risk\n\n" +
  "ğŸ“ˆ LONGER WINDOW (60-100): More stable adjustments, considers long-term performance\n" +
  "ğŸ“‰ SHORTER WINDOW (20-40): More responsive, focuses on recent performance\n\n" +
  "ğŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping: 20-30 (recent performance focus)\n" +
  "â€¢ Day Trading: 30-50 (balanced)\n" +
  "â€¢ Swing Trading: 50-80 (long-term trends)\n\n" +
  "ğŸ¦ SECTOR RECOMMENDATIONS:\n" +
  "â€¢ Crypto: 20-40 (volatile, recent focus)\n" +
  "â€¢ Stocks: 40-60 (stable markets)\n" +
  "â€¢ Forex: 50-80 (smooth trends)\n" +
  "â€¢ Indices: 40-60 (trending markets)\n\n" +
  "ğŸ’¡ PRO TIP: Use shorter windows in fast-moving markets, longer windows for stable trends")
// ==============================================================================
// ğŸ›¡ï¸ RISK MANAGEMENT
// ==============================================================================
group_risk = "ğŸ›¡ï¸ Risk Management"
ACCOUNT_SIZE = input.float(100000, "ğŸ’° Account Size", minval=1000, group=group_risk,
  tooltip="ğŸ¯ WHAT IT IS: Total account balance used for position sizing calculations\n\n" +
  "âš¡ HOW IT WORKS: Determines the base capital for risk percentage calculations\n\n" +
  "ğŸ“ˆ HIGHER VALUES: Allows larger position sizes, suitable for well-funded accounts\n" +
  "ğŸ“‰ LOWER VALUES: Reduces position sizes, ideal for smaller accounts\n\n" +
  "ğŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping: Any (scales with risk)\n" +
  "â€¢ Day Trading: Any (scales with risk)\n" +
  "â€¢ Swing Trading: Any (scales with risk)\n\n" +
  "ğŸ¦ SECTOR RECOMMENDATIONS:\n" +
  "â€¢ All Sectors: Set to your actual account size\n\n" +
  "ğŸ’¡ PRO TIP: Update regularly to reflect actual account balance for accurate sizing")
BASE_RISK = input.float(0.008, "ğŸ² Base Risk Per Trade %", minval=0.003, maxval=0.02, step=0.001, group=group_risk,
  tooltip="ğŸ¯ WHAT IT IS: Percentage of account risked per trade\n\n" +
  "âš¡ HOW IT WORKS: Defines the base risk level for position sizing calculations\n\n" +
  "ğŸ“ˆ HIGHER VALUES (0.015-0.02): Larger positions, higher potential reward and risk\n" +
  "ğŸ“‰ LOWER VALUES (0.003-0.01): Smaller positions, lower risk, more conservative\n\n" +
  "ğŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping: 0.003-0.007 (many trades, low risk per trade)\n" +
  "â€¢ Day Trading: 0.007-0.012 (balanced)\n" +
  "â€¢ Swing Trading: 0.01-0.015 (fewer, higher-quality trades)\n\n" +
  "ğŸ¦ SECTOR RECOMMENDATIONS:\n" +
  "â€¢ Crypto: 0.003-0.008 (high volatility)\n" +
  "â€¢ Stocks: 0.007-0.012 (stable markets)\n" +
  "â€¢ Forex: 0.008-0.015 (smooth trends)\n" +
  "â€¢ Indices: 0.007-0.012 (trending markets)\n\n" +
  "ğŸ’¡ PRO TIP: Start with 0.008 and adjust based on risk tolerance and win rate")
MAX_DAILY_TRADES = input.int(12, "ğŸš« Max Daily Trades", minval=5, maxval=25, group=group_risk,
  tooltip="ğŸ¯ WHAT IT IS: Maximum number of trades allowed per day\n\n" +
  "âš¡ HOW IT WORKS: Limits trading activity to manage exposure and over-trading\n\n" +
  "ğŸ“ˆ HIGHER VALUES (15-25): Allows more trades, suitable for scalping or volatile markets\n" +
  "ğŸ“‰ LOWER VALUES (5-10): Restricts trading, ideal for conservative or swing trading\n\n" +
  "ğŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping: 15-25 (high-frequency trading)\n" +
  "â€¢ Day Trading: 10-15 (balanced)\n" +
  "â€¢ Swing Trading: 5-10 (fewer trades)\n\n" +
  "ğŸ¦ SECTOR RECOMMENDATIONS:\n" +
  "â€¢ Crypto: 15-25 (volatile markets)\n" +
  "â€¢ Stocks: 8-15 (stable markets)\n" +
  "â€¢ Forex: 5-10 (smooth trends)\n" +
  "â€¢ Indices: 8-15 (trending markets)\n\n" +
  "ğŸ’¡ PRO TIP: Use lower values to avoid over-trading in choppy markets")
// ==============================================================================
// â° SESSION
// ==============================================================================
group_session = "â° Session"
session_start = input.int(5, "ğŸ•’ Session Start Hour (24h)", minval=0, maxval=23, group=group_session,
  tooltip="ğŸ¯ WHAT IT IS: Start hour for allowed trading session\n\n" +
  "âš¡ HOW IT WORKS: Restricts trading to specific hours to align with market activity\n\n" +
  "ğŸ“ˆ HIGHER VALUES: Later start, suitable for specific market sessions (e.g., US afternoon)\n" +
  "ğŸ“‰ LOWER VALUES: Earlier start, captures early market moves\n\n" +
  "ğŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping: Align with high-volume hours (e.g., 8-11 for US open)\n" +
  "â€¢ Day Trading: Align with market open/close (e.g., 9-16 for US)\n" +
  "â€¢ Swing Trading: Broader session (e.g., 5-20)\n\n" +
  "ğŸ¦ SECTOR RECOMMENDATIONS:\n" +
  "â€¢ Stocks: 9-16 (US market hours)\n" +
  "â€¢ Crypto: 0-23 (24/7 markets)\n" +
  "â€¢ Forex: 0-23 or align with major sessions (e.g., London 3-12)\n" +
  "â€¢ Indices: 9-16 (US market hours)\n\n" +
  "ğŸ’¡ PRO TIP: Set to match your target marketâ€™s active hours for best results")
session_end = input.int(16, "ğŸ•” Session End Hour (24h)", minval=0, maxval=23, group=group_session,
  tooltip="ğŸ¯ WHAT IT IS: End hour for allowed trading session\n\n" +
  "âš¡ HOW IT WORKS: Stops trading after the specified hour to avoid low-liquidity periods\n\n" +
  "ğŸ“ˆ HIGHER VALUES: Extends trading into later hours, captures full market sessions\n" +
  "ğŸ“‰ LOWER VALUES: Ends trading earlier, avoids volatile closes\n\n" +
  "ğŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping: End at high-volume close (e.g., 15-16 for US)\n" +
  "â€¢ Day Trading: End at market close (e.g., 16 for US)\n" +
  "â€¢ Swing Trading: Broader session (e.g., 20)\n\n" +
  "ğŸ¦ SECTOR RECOMMENDATIONS:\n" +
  "â€¢ Stocks: 16 (US market close)\n" +
  "â€¢ Crypto: 23 (24/7 markets)\n" +
  "â€¢ Forex: Align with session close (e.g., 12 for London)\n" +
  "â€¢ Indices: 16 (US market close)\n\n" +
  "ğŸ’¡ PRO TIP: Avoid trading during low-liquidity hours to reduce slippage")
allow_weekend = input.bool(false, "ğŸŒ™ Allow Weekend Trading?", group=group_session,
  tooltip="ğŸ¯ WHAT IT IS: Permits trading on weekends for 24/7 markets like crypto\n\n" +
  "âš¡ HOW IT WORKS: Enables or disables trading on Saturday and Sunday\n\n" +
  "ğŸ“ˆ ENABLED: Allows trading in 24/7 markets, maximizes opportunities\n" +
  "ğŸ“‰ DISABLED: Restricts trading to weekdays, avoids low-liquidity periods\n\n" +
  "ğŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping: Enable for crypto, disable for others\n" +
  "â€¢ Day Trading: Enable for crypto, disable for others\n" +
  "â€¢ Swing Trading: Disable (focus on weekday trends)\n\n" +
  "ğŸ¦ SECTOR RECOMMENDATIONS:\n" +
  "â€¢ Crypto: Enable (24/7 markets)\n" +
  "â€¢ Stocks: Disable (closed weekends)\n" +
  "â€¢ Forex: Disable (low liquidity weekends)\n" +
  "â€¢ Indices: Disable (closed weekends)\n\n" +
  "ğŸ’¡ PRO TIP: Enable only for crypto markets with sufficient weekend liquidity")
session_timezone = input.string("America/Chicago", "ğŸŒ Session Timezone", options=["America/New_York", "America/Chicago", "America/Los_Angeles", "Europe/London", "Europe/Frankfurt", "Europe/Moscow", "Asia/Tokyo", "Asia/Hong_Kong", "Asia/Shanghai", "Asia/Singapore", "Australia/Sydney", "UTC"], group=group_session,
  tooltip="ğŸ¯ WHAT IT IS: Timezone for defining trading session hours\n\n" +
  "âš¡ HOW IT WORKS: Aligns session start/end times with the selected timezone\n\n" +
  "ğŸ“ˆ CHOOSING TIMEZONE: Select the timezone of your target market for accurate session timing\n\n" +
  "ğŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping: Match primary market (e.g., America/New_York for US stocks)\n" +
  "â€¢ Day Trading: Match primary market\n" +
  "â€¢ Swing Trading: Match primary market or UTC for flexibility\n\n" +
  "ğŸ¦ SECTOR RECOMMENDATIONS:\n" +
  "â€¢ Stocks: America/New_York (US) or relevant exchange\n" +
  "â€¢ Crypto: UTC (global 24/7 markets)\n" +
  "â€¢ Forex: Europe/London or UTC (major sessions)\n" +
  "â€¢ Indices: America/New_York or relevant exchange\n\n" +
  "ğŸ’¡ PRO TIP: Use UTC for crypto or global markets, local timezone for stocks/indices")
// ==============================================================================
// ğŸ¨ VISUAL CONFIGURATION
// ==============================================================================
group_visual = "ğŸ¨ Visual Configuration"
visual_theme = input.string("Quantum Nebula", "ğŸ¨ Visual Theme", options=["Quantum Nebula", "Ethereal Prism", "Dark Matter", "Cosmic Aurora", "Void Resonance", "Temporal Flux", "Astral Projection"], group=group_visual,
  tooltip="ğŸ¯ WHAT IT IS: Defines the color scheme and aesthetic of the dashboard\n\n" +
  "âš¡ HOW IT WORKS: Sets the visual style for all indicators and dashboard elements\n\n" +
  "ğŸŒˆ THEME PERSONALITIES:\n" +
  "â€¢ ğŸŒŒ QUANTUM NEBULA: Deep purples, cosmic accents, mathematical elegance\n" +
  "â€¢ ğŸ”® ETHEREAL PRISM: Iridescent rainbow, vibrant and crypto-friendly\n" +
  "â€¢ âš« DARK MATTER: Monochromatic with energy bursts, minimalist\n" +
  "â€¢ ğŸŒ… COSMIC AURORA: Northern lights-inspired, vibrant greens\n" +
  "â€¢ ğŸ•³ï¸ VOID RESONANCE: Deep space with neon, high contrast\n" +
  "â€¢ â° TEMPORAL FLUX: Time-distortion colors, dynamic reds\n" +
  "â€¢ ğŸ‘ï¸ ASTRAL PROJECTION: Ethereal amber, out-of-body aesthetic\n\n" +
  "ğŸ¯ MARKET MATCHING:\n" +
  "â€¢ Stocks: Quantum Nebula, Dark Matter\n" +
  "â€¢ Crypto: Ethereal Prism, Void Resonance\n" +
  "â€¢ Forex: Cosmic Aurora, Temporal Flux\n" +
  "â€¢ Indices: Quantum Nebula, Astral Projection\n\n" +
  "ğŸ’¡ PRO TIP: Choose a theme that matches your trading style and screen setup for visual comfort")
show_holonomy_field = input.bool(true, "ğŸŒ€ Show Holonomy Field", group=group_visual,
  tooltip="ğŸ¯ WHAT IT IS: Multi-layer visualization of market resonance zones\n\n" +
  "âš¡ HOW IT WORKS: Displays dynamic price bands based on holonomy calculations\n\n" +
  "ğŸ“ˆ BENEFITS: Highlights key price zones for potential reversals or continuations\n" +
  "ğŸ“‰ DRAWBACKS: May clutter charts on lower timeframes\n\n" +
  "ğŸ•’ RECOMMENDED FOR:\n" +
  "â€¢ Swing Trading: Always ON\n" +
  "â€¢ Day Trading: ON for major trends\n" +
  "â€¢ Scalping: OFF (avoid clutter)\n\n" +
  "ğŸ’¡ USAGE: Watch for price interactions with field zones for trade signals")
show_quantum_portals = input.bool(true, "ğŸŒŒ Show Quantum Portals", group=group_visual,
  tooltip="ğŸ¯ WHAT IT IS: Visualizes entry signals with recursive depth patterns\n\n" +
  "âš¡ FEATURES:\n" +
  "â€¢ Triangle markers for entries\n" +
  "â€¢ Colored portals showing directional flow\n" +
  "â€¢ Recursive depth for momentum strength\n\n" +
  "ğŸ¯ VISUAL BENEFITS:\n" +
  "â€¢ Clear entry signal identification\n" +
  "â€¢ Momentum direction visualization\n" +
  "â€¢ Signal strength indication\n\n" +
  "ğŸ’¡ OPTIMIZATION: Turn OFF for cleaner charts, ON for maximum signal clarity")
show_anomaly_grid = input.bool(true, "ğŸ“ Show Anomaly Detection Grid", group=group_visual,
  tooltip="ğŸ¯ WHAT IT IS: Dynamic support/resistance levels with anomaly scores\n\n" +
  "âš¡ HOW IT WORKS: Plots fractal highs/lows with calculated anomaly strength\n\n" +
  "ğŸ“ˆ BENEFITS: Precise entry/exit timing, anomaly-based trade validation\n" +
  "ğŸ“‰ DRAWBACKS: Can overwhelm lower timeframes with multiple lines\n\n" +
  "ğŸ•’ RECOMMENDED FOR:\n" +
  "â€¢ Swing Trading: Always ON\n" +
  "â€¢ Day Trading: ON for key levels\n" +
  "â€¢ Scalping: OFF (too cluttered)\n\n" +
  "ğŸ’¡ USAGE: Combine with holonomy field for high-probability setups")
show_field_resonance = input.bool(true, "ã€°ï¸ Show Field Resonance Bands", group=group_visual,
  tooltip="ğŸ¯ WHAT IT IS: Visualizes harmonic price zones based on market strength\n\n" +
  "âš¡ HOW IT WORKS: Plots bands around key price levels to indicate resonance strength\n\n" +
  "ğŸ“ˆ BENEFITS: Identifies high-probability support/resistance zones\n" +
  "ğŸ“‰ DRAWBACKS: May add visual complexity on volatile charts\n\n" +
  "ğŸ•’ RECOMMENDED FOR:\n" +
  "â€¢ Swing Trading: Always ON\n" +
  "â€¢ Day Trading: ON for trend confirmation\n" +
  "â€¢ Scalping: OFF (avoid clutter)\n\n" +
  "ğŸ’¡ USAGE: Trade bounces or breaks from resonance bands with signal confirmation")
show_phase_flow = input.bool(true, "ğŸŒŠ Show Phase Space Flow", group=group_visual,
  tooltip="ğŸ¯ WHAT IT IS: Background heatmap showing market topology and momentum\n\n" +
  "âš¡ HOW IT WORKS: Uses price and volume dynamics to create intensity-based background\n\n" +
  "ğŸ¨ INTENSITY LEVELS:\n" +
  "â€¢ Dark: Low activity, range-bound markets\n" +
  "â€¢ Medium: Moderate momentum, building trends\n" +
  "â€¢ Bright: High activity, strong trends\n\n" +
  "ğŸ¯ TRADING INSIGHT: Bright backgrounds indicate high-probability setups\n" +
  "ğŸ’¡ PRO TIP: Trade aggressively when phase flow is bright, conservatively when dark")
field_intensity = input.int(75, "ğŸŒ«ï¸ Field Transparency", minval=70, maxval=95, group=group_visual,
  tooltip="ğŸ¯ WHAT IT IS: Controls transparency of holonomy field and resonance bands\n\n" +
  "âš¡ SETTINGS:\n" +
  "â€¢ 70-75: Bold visuals, strong impact\n" +
  "â€¢ 80-85: Balanced visibility\n" +
  "â€¢ 90-95: Subtle, minimal interference\n\n" +
  "ğŸ¯ CHART PREFERENCES:\n" +
  "â€¢ Busy Charts: 90-95\n" +
  "â€¢ Balanced Charts: 80-85\n" +
  "â€¢ Detailed Visuals: 70-75\n\n" +
  "ğŸ’¡ OPTIMIZATION: Adjust based on chart background and personal preference")
portal_depth = input.int(5, "ğŸ”„ Portal Recursion Depth", minval=3, maxval=8, group=group_visual,
  tooltip="ğŸ¯ WHAT IT IS: Number of recursive layers in quantum portal visualization\n\n" +
  "âš¡ HOW IT WORKS: Creates nested patterns to indicate signal strength and momentum\n\n" +
  "ğŸ“ˆ HIGHER DEPTH (6-8): More complex patterns, deeper momentum insight\n" +
  "ğŸ“‰ LOWER DEPTH (3-4): Simpler patterns, less visual complexity\n\n" +
  "ğŸ¯ PERFORMANCE OPTIMIZATION:\n" +
  "â€¢ Fast Charts: 3-4 (lower CPU usage)\n" +
  "â€¢ Detailed Analysis: 5-6 (balanced)\n" +
  "â€¢ Maximum Insight: 6-8 (complex patterns)\n\n" +
  "ğŸ’¡ BALANCE: Higher depth provides more insight but increases visual clutter")
// ==============================================================================
// ğŸ”¬ ADVANCED CONFIGURATION
// ==============================================================================
group_advanced = "ğŸ”¬ Advanced Configuration"
anomaly_threshold = input.float(30.0, "âš ï¸ Anomaly Threshold", minval=0, maxval=100, step=5.0, group=group_advanced,
  tooltip="ğŸ¯ WHAT IT IS: Minimum anomaly level required to highlight significant market events\n\n" +
  "âš¡ HOW IT WORKS: Filters anomaly grid levels based on price and volume deviations\n\n" +
  "ğŸ“ˆ HIGHER VALUES (50-100): Fewer anomalies, focuses on extreme events\n" +
  "ğŸ“‰ LOWER VALUES (0-30): More anomalies, captures smaller deviations\n\n" +
  "ğŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping: 10-20 (capture small anomalies)\n" +
  "â€¢ Day Trading: 20-40 (balanced)\n" +
  "â€¢ Swing Trading: 40-60 (major events)\n\n" +
  "ğŸ¦ SECTOR RECOMMENDATIONS:\n" +
  "â€¢ Crypto: 10-30 (volatile markets)\n" +
  "â€¢ Stocks: 20-40 (stable markets)\n" +
  "â€¢ Forex: 30-50 (smooth trends)\n" +
  "â€¢ Indices: 20-40 (trending markets)\n\n" +
  "ğŸ’¡ PRO TIP: Adjust based on market volatility to filter noise")
portal_threshold = input.float(0.7, "ğŸŒŒ Portal Threshold", minval=0, maxval=1, step=0.1, group=group_advanced,
  tooltip="ğŸ¯ WHAT IT IS: Minimum signal strength for displaying quantum portals\n\n" +
  "âš¡ HOW IT WORKS: Filters portal visualizations to show only high-confidence signals\n\n" +
  "ğŸ“ˆ HIGHER VALUES (0.8-1.0): Fewer portals, higher quality signals\n" +
  "ğŸ“‰ LOWER VALUES (0.0-0.5): More portals, includes weaker signals\n\n" +
  "ğŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping: 0.3-0.5 (frequent signals)\n" +
  "â€¢ Day Trading: 0.5-0.7 (balanced)\n" +
  "â€¢ Swing Trading: 0.7-0.9 (high-confidence)\n\n" +
  "ğŸ¦ SECTOR RECOMMENDATIONS:\n" +
  "â€¢ Crypto: 0.3-0.5 (volatile markets)\n" +
  "â€¢ Stocks: 0.5-0.7 (stable markets)\n" +
  "â€¢ Forex: 0.6-0.8 (smooth trends)\n" +
  "â€¢ Indices: 0.5-0.7 (trending markets)\n\n" +
  "ğŸ’¡ PRO TIP: Use higher thresholds for cleaner charts and stronger signals")
// ==============================================================================
// ğŸ“Š DASHBOARD CONFIGURATION
// ==============================================================================
group_dashboard = "ğŸ“Š Dashboard Configuration"
show_dashboard = input.bool(true, "ğŸ“‹ Show Enhanced Dashboard", group=group_dashboard,
  tooltip="ğŸ¯ WHAT IT IS: Displays a comprehensive panel with key trading metrics\n\n" +
  "âš¡ HOW IT WORKS: Shows holonomy score, anomaly level, quantum state, and trade signals\n\n" +
  "ğŸ“Š DASHBOARD INCLUDES:\n" +
  "â€¢ Holonomy Score (momentum strength)\n" +
  "â€¢ Anomaly Level (market events)\n" +
  "â€¢ Quantum State (market bias)\n" +
  "â€¢ Long/Short Signals\n" +
  "â€¢ Trend Direction\n\n" +
  "ğŸ¯ BENEFITS:\n" +
  "â€¢ Quick decision-making\n" +
  "â€¢ Real-time market insights\n" +
  "â€¢ Performance tracking\n\n" +
  "ğŸ’¡ RECOMMENDED: Keep ON for systematic trading, disable for minimal charts")
dashboard_size = input.string("Normal", "ğŸ“ Dashboard Size", options=["Small", "Normal", "Large"], group=group_dashboard,
  tooltip="ğŸ¯ WHAT IT IS: Controls the size and detail level of the dashboard\n\n" +
  "âš¡ HOW IT WORKS: Adjusts the amount of information displayed\n\n" +
  "ğŸ“± SMALL: Minimal metrics, ideal for mobile or small screens\n" +
  "ğŸ’» NORMAL: Balanced detail, suitable for most desktops\n" +
  "ğŸ–¥ï¸ LARGE: Maximum detail, best for multi-monitor setups\n\n" +
  "ğŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping: Small (quick reference)\n" +
  "â€¢ Day Trading: Normal (balanced info)\n" +
  "â€¢ Swing Trading: Large (detailed analysis)\n\n" +
  "ğŸ¦ SECTOR RECOMMENDATIONS:\n" +
  "â€¢ All Sectors: Normal (versatile)\n\n" +
  "ğŸ’¡ PRO TIP: Use Normal for most setups, Large for deep analysis")
dashboard_position_input = input.string("Top Right", "ğŸ“ Dashboard Position", options=["Top Left", "Top Right", "Bottom Left", "Bottom Right"], group=group_dashboard,
  tooltip="ğŸ¯ WHAT IT IS: Sets the dashboardâ€™s position on the chart\n\n" +
  "âš¡ HOW IT WORKS: Places the dashboard in a non-intrusive location\n\n" +
  "ğŸ“ TOP RIGHT: Standard placement, avoids price action\n" +
  "ğŸ“ TOP LEFT: Good for wide charts or left-handed users\n" +
  "ğŸ“ BOTTOM RIGHT: Focuses on recent price action, ideal for scalping\n" +
  "ğŸ“ BOTTOM LEFT: Maximizes price visibility, good for swing trading\n\n" +
  "ğŸ•’ TIMEFRAME OPTIMIZATION:\n" +
  "â€¢ Scalping: Bottom Right (recent price focus)\n" +
  "â€¢ Day Trading: Top Right (standard)\n" +
  "â€¢ Swing Trading: Bottom Left (price visibility)\n\n" +
  "ğŸ¦ SECTOR RECOMMENDATIONS:\n" +
  "â€¢ All Sectors: Top Right (versatile)\n\n" +
  "ğŸ’¡ PRO TIP: Choose a position that doesnâ€™t obscure key chart areas")
// ==============================================================================
// COLOR SCHEME DEFINITIONS
// ==============================================================================
// Quantum Nebula - Deep space purples with cosmic accents
color qn_primary = #8B5CF6      // Vibrant purple
color qn_secondary = #A78BFA    // Light purple
color qn_accent = #C084FC       // Bright purple
color qn_positive = #10B981     // Emerald
color qn_negative = #EF4444     // Red
color qn_anomaly_strong = #FBBF24  // Amber
color qn_anomaly_weak = #F59E0B    // Orange
color qn_field_glow = #E0E7FF      // Light indigo
color qn_phase_intense = #4C1D95   // Deep purple
color qn_phase_normal = #7C3AED    // Purple
// Ethereal Prism - Iridescent rainbow cascade
color ep_primary = #06B6D4      // Cyan
color ep_secondary = #0891B2    // Dark cyan
color ep_accent = #0EA5E9       // Sky blue
color ep_positive = #84CC16     // Lime
color ep_negative = #F43F5E     // Rose
color ep_anomaly_strong = #A855F7  // Purple
color ep_anomaly_weak = #E879F9    // Fuchsia
color ep_field_glow = #CFFAFE      // Cyan tint
color ep_phase_intense = #0C4A6E   // Deep blue
color ep_phase_normal = #0284C7    // Blue
// Dark Matter - Monochromatic with energy bursts
color dm_primary = #64748B      // Slate
color dm_secondary = #94A3B8    // Light slate
color dm_accent = #CBD5E1       // Lightest slate
color dm_positive = #22D3EE     // Cyan burst
color dm_negative = #F97316     // Orange burst
color dm_anomaly_strong = #FACC15  // Yellow energy
color dm_anomaly_weak = #FDE047    // Light yellow
color dm_field_glow = #F1F5F9      // Near white
color dm_phase_intense = #1E293B   // Dark slate
color dm_phase_normal = #475569    // Medium slate
// Cosmic Aurora - Northern lights inspiration
color ca_primary = #059669      // Emerald
color ca_secondary = #10B981    // Light emerald
color ca_accent = #34D399       // Bright green
color ca_positive = #06B6D4     // Cyan
color ca_negative = #EC4899     // Pink
color ca_anomaly_strong = #8B5CF6  // Purple aurora
color ca_anomaly_weak = #A78BFA    // Light purple
color ca_field_glow = #D1FAE5      // Mint tint
color ca_phase_intense = #064E3B   // Deep green
color ca_phase_normal = #047857    // Green
// Void Resonance - Deep space with neon accents
color vr_primary = #1F2937      // Gray-900
color vr_secondary = #374151    // Gray-700
color vr_accent = #4B5563       // Gray-600
color vr_positive = #00F5FF     // Neon cyan
color vr_negative = #FF006E     // Neon pink
color vr_anomaly_strong = #FFFF00  // Neon yellow
color vr_anomaly_weak = #9333EA    // Neon purple
color vr_field_glow = #111827      // Near black
color vr_phase_intense = #000000   // Black
color vr_phase_normal = #1F2937    // Dark gray
// Temporal Flux - Time distortion colors
color tf_primary = #DC2626      // Red
color tf_secondary = #F87171    // Light red
color tf_accent = #FCA5A5       // Pink red
color tf_positive = #059669     // Green
color tf_negative = #7C3AED     // Purple
color tf_anomaly_strong = #0891B2  // Cyan
color tf_anomaly_weak = #06B6D4    // Light cyan
color tf_field_glow = #FEE2E2      // Red tint
color tf_phase_intense = #7F1D1D   // Dark red
color tf_phase_normal = #B91C1C    // Medium red
// Astral Projection - Ethereal out-of-body experience
color ap_primary = #F59E0B      // Amber
color ap_secondary = #FCD34D    // Light amber
color ap_accent = #FDE68A       // Pale amber
color ap_positive = #8B5CF6     // Purple
color ap_negative = #0EA5E9     // Blue
color ap_anomaly_strong = #EC4899  // Pink
color ap_anomaly_weak = #F9A8D4    // Light pink
color ap_field_glow = #FEF3C7      // Amber tint
color ap_phase_intense = #78350F   // Dark amber
color ap_phase_normal = #D97706    // Orange
// ==============================================================================
// DYNAMIC COLOR SELECTION
// ==============================================================================
holonomy_primary = visual_theme == "Quantum Nebula" ? qn_primary : 
                   visual_theme == "Ethereal Prism" ? ep_primary :
                   visual_theme == "Dark Matter" ? dm_primary :
                   visual_theme == "Cosmic Aurora" ? ca_primary :
                   visual_theme == "Void Resonance" ? vr_primary :
                   visual_theme == "Temporal Flux" ? tf_primary : ap_primary
holonomy_secondary = visual_theme == "Quantum Nebula" ? qn_secondary :
                     visual_theme == "Ethereal Prism" ? ep_secondary :
                     visual_theme == "Dark Matter" ? dm_secondary :
                     visual_theme == "Cosmic Aurora" ? ca_secondary :
                     visual_theme == "Void Resonance" ? vr_secondary :
                     visual_theme == "Temporal Flux" ? tf_secondary : ap_secondary
holonomy_accent = visual_theme == "Quantum Nebula" ? qn_accent :
                  visual_theme == "Ethereal Prism" ? ep_accent :
                  visual_theme == "Dark Matter" ? dm_accent :
                  visual_theme == "Cosmic Aurora" ? ca_accent :
                  visual_theme == "Void Resonance" ? vr_accent :
                  visual_theme == "Temporal Flux" ? tf_accent : ap_accent
quantum_positive = visual_theme == "Quantum Nebula" ? qn_positive :
                   visual_theme == "Ethereal Prism" ? ep_positive :
                   visual_theme == "Dark Matter" ? dm_positive :
                   visual_theme == "Cosmic Aurora" ? ca_positive :
                   visual_theme == "Void Resonance" ? vr_positive :
                   visual_theme == "Temporal Flux" ? tf_positive : ap_positive
quantum_negative = visual_theme == "Quantum Nebula" ? qn_negative :
                   visual_theme == "Ethereal Prism" ? ep_negative :
                   visual_theme == "Dark Matter" ? dm_negative :
                   visual_theme == "Cosmic Aurora" ? ca_negative :
                   visual_theme == "Void Resonance" ? vr_negative :
                   visual_theme == "Temporal Flux" ? tf_negative : ap_negative
anomaly_strong = visual_theme == "Quantum Nebula" ? qn_anomaly_strong :
                 visual_theme == "Ethereal Prism" ? ep_anomaly_strong :
                 visual_theme == "Dark Matter" ? dm_anomaly_strong :
                 visual_theme == "Cosmic Aurora" ? ca_anomaly_strong :
                 visual_theme == "Void Resonance" ? vr_anomaly_strong :
                 visual_theme == "Temporal Flux" ? tf_anomaly_strong : ap_anomaly_strong
anomaly_weak = visual_theme == "Quantum Nebula" ? qn_anomaly_weak :
               visual_theme == "Ethereal Prism" ? ep_anomaly_weak :
               visual_theme == "Dark Matter" ? dm_anomaly_weak :
               visual_theme == "Cosmic Aurora" ? ca_anomaly_weak :
               visual_theme == "Void Resonance" ? vr_anomaly_weak :
               visual_theme == "Temporal Flux" ? tf_anomaly_weak : ap_anomaly_weak
field_glow = visual_theme == "Quantum Nebula" ? qn_field_glow :
             visual_theme == "Ethereal Prism" ? ep_field_glow :
             visual_theme == "Dark Matter" ? dm_field_glow :
             visual_theme == "Cosmic Aurora" ? ca_field_glow :
             visual_theme == "Void Resonance" ? vr_field_glow :
             visual_theme == "Temporal Flux" ? tf_field_glow : ap_field_glow
phase_intense = visual_theme == "Quantum Nebula" ? qn_phase_intense : visual_theme == "Ethereal Prism" ? ep_phase_intense : visual_theme == "Dark Matter" ? dm_phase_intense : visual_theme == "Cosmic Aurora" ? ca_phase_intense : visual_theme == "Void Resonance" ? vr_phase_intense : visual_theme == "Temporal Flux" ? tf_phase_intense : ap_phase_intense
phase_normal = visual_theme == "Quantum Nebula" ? qn_phase_normal :
               visual_theme == "Ethereal Prism" ? ep_phase_normal :
               visual_theme == "Dark Matter" ? dm_phase_normal :
               visual_theme == "Cosmic Aurora" ? ca_phase_normal :
               visual_theme == "Void Resonance" ? vr_phase_normal :
               visual_theme == "Temporal Flux" ? tf_phase_normal : ap_phase_normal
// ========================================
// HELPER FUNCTION FOR DASHBOARD POSITION
// ========================================
f_getTablePosition(position_string) =>
    switch position_string
        "Top Left" => position.top_left
        "Top Right" => position.top_right
        "Bottom Left" => position.bottom_left
        "Bottom Right" => position.bottom_right
        => position.top_right  // Default to top_right if invalid
// ========================================
// TIME AND SESSION LOGIC
// ========================================
bar_hour = hour(time, session_timezone)
bar_dow = dayofweek(time, session_timezone)
in_session = (session_start < session_end ? (bar_hour >= session_start and bar_hour < session_end) : (bar_hour >= session_start or bar_hour < session_end))
not_weekend = allow_weekend or (bar_dow != dayofweek.saturday and bar_dow != dayofweek.sunday)
trade_allowed = in_session and not_weekend
// ========================================
// CORE INDICATORS
// ========================================
rsi_confirmed = ta.rsi(close, 14)
ema20_confirmed = ta.ema(close, 20)
ema50_confirmed = ta.ema(close, 50)
[macd_line_confirmed, signal_line_confirmed, histogram_confirmed] = ta.macd(close, 12, 26, 9)
atr_confirmed = ta.atr(14)
vol_avg_confirmed = ta.sma(volume, 20)
htf_trend = request.security(syminfo.tickerid, "60", ta.ema(close, 20), lookahead=barmerge.lookahead_off)
// Calculate Fibonacci levels for additional resonance
price_range = ta.highest(high, 55) - ta.lowest(low, 55)
range_low = ta.lowest(low, 55)
// ========================================
// HOLONOMY FIELD CALCULATION
// ========================================
calculateRobustSignal() =>
    roc = (close - close[10]) / close[10] * 100
    vwap_distance = (close - ta.vwap(hlc3)) / close * 100
    signal = 0.0
    if close > htf_trend and close > ema20_confirmed
        signal += 1.0 * (close > ema50_confirmed ? 1.5 : 1.0)
        if roc > 0
            signal += roc / 10
        if volume > vol_avg_confirmed * 1.2
            signal += 0.5
    else if close < htf_trend and close < ema20_confirmed
        signal -= 1.0 * (close < ema50_confirmed ? 1.5 : 1.0)
        if roc < 0
            signal += roc / 10
        if volume > vol_avg_confirmed * 1.2
            signal -= 0.5
    vwap_contrib = math.max(-2, math.min(2, vwap_distance))
    signal += vwap_contrib
    if rsi_confirmed < 30 and signal > 0
        signal += 1.5
    else if rsi_confirmed < 40 and signal > 0
        signal += 0.5
    else if rsi_confirmed > 70 and signal < 0
        signal -= 1.5
    else if rsi_confirmed > 60 and signal < 0
        signal -= 0.5
    if macd_line_confirmed > signal_line_confirmed and signal > 0
        signal += 0.5
    else if macd_line_confirmed < signal_line_confirmed and signal < 0
        signal -= 0.5
    signal * SCORE_AMPLIFIER / 10
// ========================================
// MARKET REGIME FILTER
// ========================================
volatility_regime = atr_confirmed / close * 100
volatility_percentile_30 = ta.percentile_nearest_rank(volatility_regime, 100, 30)
volatility_percentile_70 = ta.percentile_nearest_rank(volatility_regime, 100, 70)
low_vol = volatility_regime < volatility_percentile_30
high_vol = volatility_regime > volatility_percentile_70
mode_multiplier = EXECUTION_MODE == "Conservative" ? 1.3 : EXECUTION_MODE == "Aggressive" ? 0.7 : 1.0
signal_threshold = low_vol ? SIGNAL_SENSITIVITY * 0.7 * mode_multiplier : high_vol ? SIGNAL_SENSITIVITY * 1.3 * mode_multiplier : SIGNAL_SENSITIVITY * mode_multiplier
// ========================================
// SIGNAL CALCULATION
// ========================================
float signal_strength_confirmed = calculateRobustSignal()
// ========================================
// ADAPTIVE LEARNING SYSTEM
// ========================================
var array<float> trade_performance = array.new_float(PERFORMANCE_TRACKING)
var float adaptive_risk_multiplier = 1.0
var float win_rate = 0.5
var float avg_win = 0.0
var float avg_loss = 0.0
var bool market_regime_bullish = true
if strategy.closedtrades > strategy.closedtrades[1] and barstate.isconfirmed and ENABLE_LEARNING
    last_trade_return = strategy.closedtrades.profit(strategy.closedtrades - 1) / ACCOUNT_SIZE
    array.unshift(trade_performance, last_trade_return)
    if array.size(trade_performance) > PERFORMANCE_TRACKING
        array.pop(trade_performance)
    if array.size(trade_performance) >= 20
        wins = 0
        total_win = 0.0
        total_loss = 0.0
        win_count = 0
        loss_count = 0
        for i = 0 to array.size(trade_performance) - 1
            perf = array.get(trade_performance, i)
            if perf > 0
                wins += 1
                total_win += perf
                win_count += 1
            else
                total_loss += math.abs(perf)
                loss_count += 1
        win_rate := array.size(trade_performance) > 0 ? wins / array.size(trade_performance) : 0.5
        avg_win := win_count > 0 ? total_win / win_count : 0.0
        avg_loss := loss_count > 0 ? total_loss / loss_count : 0.0
        if barstate.isconfirmed
            if total_loss > 0 and (total_win / total_loss) < 1.5
                adaptive_risk_multiplier := math.max(0.5, adaptive_risk_multiplier - LEARNING_SPEED * 0.2)
            else if total_loss > 0 and (total_win / total_loss) > 2.5
                adaptive_risk_multiplier := math.min(1.5, adaptive_risk_multiplier + LEARNING_SPEED * 0.1)
recent_closes = ta.sma(close, 20)
market_regime_bullish := close > recent_closes and recent_closes > ta.sma(close, 50)
// ========================================
// EXECUTION ENGINE
// ========================================
var float daily_pnl = 0.0
var int daily_trades = 0
var int last_signal_bar = 0
if dayofweek != dayofweek[1]
    daily_pnl := 0.0
    daily_trades := 0
if strategy.closedtrades > strategy.closedtrades[1]
    daily_pnl += strategy.closedtrades.profit(strategy.closedtrades - 1)
    daily_trades += 1
signal_quality_rating = ""
abs_signal = math.abs(signal_strength_confirmed)
if abs_signal >= signal_threshold * 1.5
    signal_quality_rating := "ELITE"
else if abs_signal >= signal_threshold * 1.2
    signal_quality_rating := "STRONG"
else if abs_signal >= signal_threshold
    signal_quality_rating := "GOOD"
else
    signal_quality_rating := "WEAK"
min_bars_between = EXECUTION_MODE == "Aggressive" ? MIN_SIGNAL_SEPARATION / 2 : EXECUTION_MODE == "Conservative" ? MIN_SIGNAL_SEPARATION * 2 : MIN_SIGNAL_SEPARATION
bars_since_signal = bar_index - last_signal_bar
entry_timing_good = SMART_ENTRIES ? bars_since_signal >= min_bars_between : true
max_trades_adjusted = EXECUTION_MODE == "Aggressive" ? MAX_DAILY_TRADES * 1.5 : EXECUTION_MODE == "Conservative" ? MAX_DAILY_TRADES * 0.7 : MAX_DAILY_TRADES
risk_ok = daily_trades < max_trades_adjusted
// ========================================
// POSITION SIZING
// ========================================
calculateElitePositionSize() =>
    base_risk_amount = ACCOUNT_SIZE * (BASE_RISK / 100) * adaptive_risk_multiplier
    raw_signal_mult = DYNAMIC_SIZING ? 0.5 + (math.abs(signal_strength_confirmed) / signal_threshold) * 1.5 : 1.0
    signal_mult = math.max(0.5, math.min(3.0, raw_signal_mult))
    regime_mult = market_regime_bullish and signal_strength_confirmed > 0 ? 1.2 : not market_regime_bullish and signal_strength_confirmed < 0 ? 1.2 : 0.8
    perf_mult = win_rate > 0.65 ? 1.5 : win_rate > 0.55 ? 1.2 : win_rate < 0.45 ? 0.5 : 1.0
    mode_mult = EXECUTION_MODE == "Aggressive" ? 1.8 : EXECUTION_MODE == "Conservative" ? 0.6 : 1.0
    vol_mult = atr_confirmed / ta.sma(atr_confirmed, 50)
    vol_adj = vol_mult > 1.2 ? 0.8 : vol_mult < 0.8 ? 1.3 : 1.0
    final_risk = base_risk_amount * signal_mult * regime_mult * perf_mult * mode_mult * vol_adj
    if syminfo.type == "futures"
        tick_value = syminfo.mintick * syminfo.pointvalue
        stop_ticks = (atr_confirmed * 1.5) / syminfo.mintick
        position_size = final_risk / (stop_ticks * tick_value)
        contracts = math.round(position_size)
        math.max(1, math.min(10, contracts))
    else if syminfo.type == "crypto"
        stop_percent = (atr_confirmed * 1.5) / close * 100
        position_val = final_risk / (stop_percent / 100)
        shares = position_val / close
        math.round(shares * 100) / 100
    else
        stop_percent = (atr_confirmed * 1.5) / close * 100
        position_val = final_risk / (stop_percent / 100)
        shares = position_val / close
        math.max(1, math.round(shares))
// ========================================
// STOP LOSS CALCULATION
// ========================================
calculateSmartStop(is_long) =>
    recent_range = ta.highest(high, 10) - ta.lowest(low, 10)
    pivot_point = (high[1] + low[1] + close[1]) / 3
    stop_mode_mult = EXECUTION_MODE == "Aggressive" ? 0.8 : EXECUTION_MODE == "Conservative" ? 1.5 : 1.0
    if is_long
        support = math.min(ta.lowest(low, 5), pivot_point - recent_range * 0.382)
        math.max(close - atr_confirmed * 1.5 * stop_mode_mult, support)
    else
        resistance = math.max(ta.highest(high, 5), pivot_point + recent_range * 0.382)
        math.min(close + atr_confirmed * 2 * stop_mode_mult, resistance)
current_position_size = calculateElitePositionSize()
long_stop_loss = calculateSmartStop(true)
short_stop_loss = calculateSmartStop(false)
// ========================================
// TRADE EXECUTION
// ========================================
strong_long = signal_strength_confirmed >= signal_threshold * 1.2 and strategy.position_size == 0
strong_short = signal_strength_confirmed <= -signal_threshold * 1.2 and strategy.position_size == 0
if EXECUTION_MODE == "Conservative" and SIGNAL_CONFIRMATION
    strong_long := strong_long and close > ema20_confirmed and rsi_confirmed > 30 and rsi_confirmed < 70
    strong_short := strong_short and close < ema20_confirmed and rsi_confirmed > 30 and rsi_confirmed < 70
can_trade = entry_timing_good and risk_ok and barstate.isconfirmed and trade_allowed
if strong_long and can_trade
    size = current_position_size
    stop_loss = long_stop_loss
    target_multiplier = EXECUTION_MODE == "Aggressive" ? 4.0 : EXECUTION_MODE == "Conservative" ? 2.0 : 3.0
    take_profit = close + ((close - stop_loss) * target_multiplier)
    strategy.entry("Long", strategy.long, qty=size)
    if ADVANCED_EXITS
        trail_activation = EXECUTION_MODE == "Aggressive" ? atr_confirmed * 1.5 : EXECUTION_MODE == "Conservative" ? atr_confirmed * 3.0 : atr_confirmed * 2.0
        trail_offset = EXECUTION_MODE == "Aggressive" ? atr_confirmed * 0.3 : EXECUTION_MODE == "Conservative" ? atr_confirmed * 0.8 : atr_confirmed * 0.5
        strategy.exit("LongExit", "Long", stop=stop_loss, limit=take_profit, trail_points=trail_activation, trail_offset=trail_offset)
    else
        strategy.exit("LongExit", "Long", stop=stop_loss, limit=take_profit)
    last_signal_bar := bar_index
if strong_short and can_trade
    size = current_position_size
    stop_loss = short_stop_loss
    target_multiplier = EXECUTION_MODE == "Aggressive" ? 4.0 : EXECUTION_MODE == "Conservative" ? 2.0 : 3.0
    take_profit = close - ((stop_loss - close) * target_multiplier)
    strategy.entry("Short", strategy.short, qty=size)
    if ADVANCED_EXITS
        trail_activation = EXECUTION_MODE == "Aggressive" ? atr_confirmed * 1.5 : EXECUTION_MODE == "Conservative" ? atr_confirmed * 3.0 : atr_confirmed * 2.0
        trail_offset = EXECUTION_MODE == "Aggressive" ? atr_confirmed * 0.3 : EXECUTION_MODE == "Conservative" ? atr_confirmed * 0.8 : atr_confirmed * 0.5
        strategy.exit("ShortExit", "Short", stop=stop_loss, limit=take_profit, trail_points=trail_activation, trail_offset=trail_offset)
    else
        strategy.exit("ShortExit", "Short", stop=stop_loss, limit=take_profit)
    last_signal_bar := bar_index
max_bars_in_trade = EXECUTION_MODE == "Aggressive" ? 50 : EXECUTION_MODE == "Conservative" ? 200 : 100
if strategy.position_size != 0
    bars_in_trade = bar_index - strategy.opentrades.entry_bar_index(0)
    if bars_in_trade > max_bars_in_trade
        strategy.close_all("Time Exit")
// ============================================
// HOLONOMY FIELD CALCULATIONS (GLOBAL SCOPE)
// ============================================
// Calculate dynamic field levels based on holonomy strength
field_base = ta.sma(close, 21)
field_strength = math.abs(signal_strength_confirmed) / signal_threshold
field_expansion = atr_confirmed * (0.5 + field_strength * 1.5)
// Create multiple field layers
field_upper_1 = field_base + field_expansion * 0.618
field_upper_2 = field_base + field_expansion * 1.0
field_upper_3 = field_base + field_expansion * 1.618
field_lower_1 = field_base - field_expansion * 0.618
field_lower_2 = field_base - field_expansion * 1.0
field_lower_3 = field_base - field_expansion * 1.618
// Pivot calculations (global scope)
pivot_high = ta.pivothigh(high, 5, 5)
pivot_low = ta.pivotlow(low, 5, 5)
// Fibonacci resonance calculations (global scope)
fib_236 = range_low + price_range * 0.236
fib_382 = range_low + price_range * 0.382
fib_500 = range_low + price_range * 0.500
fib_618 = range_low + price_range * 0.618
fib_786 = range_low + price_range * 0.786
// ============================================
// ALL PLOT STATEMENTS (GLOBAL SCOPE)
// ============================================
// Plot field bands
plot(show_holonomy_field ? field_upper_1 : na, "Holonomy Upper Core", color=color.new(holonomy_primary, field_intensity - 60), linewidth=2)
plot(show_holonomy_field ? field_lower_1 : na, "Holonomy Lower Core", color=color.new(holonomy_primary, field_intensity - 60), linewidth=2)
plot(show_holonomy_field ? field_upper_2 : na, "Holonomy Upper Secondary", color=color.new(holonomy_secondary, field_intensity), linewidth=1)
plot(show_holonomy_field ? field_lower_2 : na, "Holonomy Lower Secondary", color=color.new(holonomy_secondary, field_intensity), linewidth=1)
plot(show_holonomy_field ? field_upper_3 : na, "Holonomy Upper Outer", color=color.new(holonomy_accent, field_intensity + 60), linewidth=1, style=plot.style_circles)
plot(show_holonomy_field ? field_lower_3 : na, "Holonomy Lower Outer", color=color.new(holonomy_accent, field_intensity + 60), linewidth=1, style=plot.style_circles)
// Fill areas
upper_fill = plot(show_holonomy_field ? field_upper_1 : na, display=display.none)
base_fill = plot(show_holonomy_field ? field_base : na, display=display.none)
lower_fill = plot(show_holonomy_field ? field_lower_1 : na, display=display.none)
fill(upper_fill, base_fill, color=color.new(signal_strength_confirmed > 0 ? quantum_positive : quantum_negative, field_intensity + 5), title="Upper Field Fill")
fill(base_fill, lower_fill, color=color.new(signal_strength_confirmed > 0 ? quantum_positive : quantum_negative, field_intensity + 5), title="Lower Field Fill")
// Plot Fibonacci resonance levels
plot(show_field_resonance and field_strength > 0.5 ? fib_236 : na, "Fib 236", color=color.new(anomaly_weak, 60), linewidth=1, style=plot.style_circles)
plot(show_field_resonance and field_strength > 0.5 ? fib_382 : na, "Fib 382", color=color.new(anomaly_weak, 50), linewidth=1, style=plot.style_circles)
plot(show_field_resonance and field_strength > 0.5 ? fib_500 : na, "Fib 500", color=color.new(anomaly_strong, 60), linewidth=2, style=plot.style_circles)
plot(show_field_resonance and field_strength > 0.5 ? fib_618 : na, "Fib 618", color=color.new(anomaly_weak, 50), linewidth=1, style=plot.style_circles)
plot(show_field_resonance and field_strength > 0.5 ? fib_786 : na, "Fib 786", color=color.new(anomaly_weak, 60), linewidth=1, style=plot.style_circles)
// Background intensity
intensity = math.min(field_strength * 100, 100)
bg_color = color.new(phase_intense, 95 - int(intensity * 0.1))
bgcolor(show_phase_flow ? bg_color : na, title="Field Intensity Background")
// ============================================
// Holonomy Field Boxes
// ============================================
if show_holonomy_field and barstate.isconfirmed
    var array<box> field_boxes = array.new<box>()  
    if array.size(field_boxes) > 10
        for i = 0 to 4
            box.delete(array.shift(field_boxes))    
    box_left = bar_index - 1
    box_right = bar_index + 15  
    core_box = box.new(box_left, field_upper_1, box_right, field_lower_1, 
                  border_color=color.new(holonomy_primary, 80),
                  bgcolor=color.new(holonomy_primary, 94),
                  border_width=2)   
    secondary_box = box.new(box_left, field_upper_2, box_right, field_lower_2, 
                       border_color=color.new(holonomy_secondary, 85),
                       bgcolor=color.new(holonomy_secondary, 96),
                       border_width=2, border_style=line.style_dashed)   
    array.push(field_boxes, core_box)
    array.push(field_boxes, secondary_box)
// ============================================
// RESONANCE BANDS WITH LINES (LOCAL SCOPE)
// ============================================
if show_field_resonance and barstate.isconfirmed
    var array<line> resistance_lines = array.new<line>()
    var array<line> support_lines = array.new<line>()
    var array<label> resonance_labels = array.new<label>()   
    // Clean up old elements
    if array.size(resistance_lines) > 8
        for i = 0 to 3
            line.delete(array.shift(resistance_lines))
    if array.size(support_lines) > 8
        for i = 0 to 3
            line.delete(array.shift(support_lines))
    if array.size(resonance_labels) > 15
        for i = 0 to 7
            label.delete(array.shift(resonance_labels))   
    // Add new resistance levels
    if not na(pivot_high) and pivot_high > field_base
        resonance_strength = math.abs(signal_strength_confirmed) / signal_threshold
        line_color = color.new(anomaly_strong, 70 - int(resonance_strength * 15))
        line_width = resonance_strength > 1.5 ? 3 : resonance_strength > 1.0 ? 2 : 1        
        // Add resonance label
        if resonance_strength > 0.8
            res_label = label.new(bar_index + 32, pivot_high, "âš¡R", 
                                 color=color.new(anomaly_strong, 75), 
                                 textcolor=anomaly_strong, 
                                 style=label.style_label_left, 
                                 size=size.small)
            array.push(resonance_labels, res_label)    
    // Add new support levels
    if not na(pivot_low) and pivot_low < field_base
        resonance_strength = math.abs(signal_strength_confirmed) / signal_threshold
        line_color = color.new(quantum_positive, 70 - int(resonance_strength * 15))
        line_width = resonance_strength > 1.5 ? 3 : resonance_strength > 1.0 ? 2 : 1        
        // Add support label
        if resonance_strength > 0.8
            sup_label = label.new(bar_index + 32, pivot_low, "âš¡S", 
                                 color=color.new(quantum_positive, 75), 
                                 textcolor=quantum_positive, 
                                 style=label.style_label_left, 
                                 size=size.small)
            array.push(resonance_labels, sup_label)
// ========================================
// QUANTUM PORTALS
// ========================================
if show_quantum_portals and (strong_long or strong_short)
    for i = 1 to portal_depth
        portal_size = i * atr_confirmed * 0.3
        portal_y = strong_long ? low - portal_size : high + portal_size
        portal_outer_color = strong_long ? color.new(quantum_positive, 60 + i * 10) : color.new(quantum_negative, 60 + i * 10)
        portal_inner_color = strong_long ? color.new(quantum_positive, 40 + i * 5) : color.new(anomaly_strong, 40 + i * 5)
        label.new(bar_index, portal_y, "â—‰", color=portal_outer_color, textcolor=portal_outer_color, style=label.style_none, size=size.huge)
        label.new(bar_index, portal_y, "â—", color=portal_inner_color, textcolor=portal_inner_color, style=label.style_none, size=size.large)
// ========================================
// ENHANCED FRACTAL GRID VISUALIZATION
// ========================================
if show_anomaly_grid
    // Pre-calculate all holonomy periods
    h8_high = ta.highest(high, 8)
    h8_low = ta.lowest(low, 8)
    h13_high = ta.highest(high, 13)
    h13_low = ta.lowest(low, 13)
    h21_high = ta.highest(high, 21)
    h21_low = ta.lowest(low, 21)
    h34_high = ta.highest(high, 34)
    h34_low = ta.lowest(low, 34)
    h55_high = ta.highest(high, 55)
    h55_low = ta.lowest(low, 55)   
    // Arrays fractal levels
    fractalHighs = array.from(h8_high, h13_high, h21_high, h34_high, h55_high)
    fractalLows = array.from(h8_low, h13_low, h21_low, h34_low, h55_low)    
    // Visual storage arrays
    var array<line> fractalHighGlowLines = array.new<line>()
    var array<line> fractalHighQuantumLines = array.new<line>()
    var array<line> fractalHighShadowLines = array.new<line>()
    var array<line> fractalLowGlowLines = array.new<line>()
    var array<line> fractalLowQuantumLines = array.new<line>()
    var array<line> fractalLowShadowLines = array.new<line>()
    var array<label> fractalHighLabels = array.new<label>()
    var array<label> fractalLowLabels = array.new<label>() 
    // Update only on real-time bars
    if barstate.isconfirmed
        // Clear previous visualizations
        for l in fractalHighGlowLines
            line.delete(l)
        for l in fractalHighQuantumLines
            line.delete(l)
        for l in fractalHighShadowLines
            line.delete(l)
        for l in fractalLowGlowLines
            line.delete(l)
        for l in fractalLowQuantumLines
            line.delete(l)
        for l in fractalLowShadowLines
            line.delete(l)
        for lbl in fractalHighLabels
            label.delete(lbl)
        for lbl in fractalLowLabels
            label.delete(lbl)        
        array.clear(fractalHighGlowLines)
        array.clear(fractalHighQuantumLines)
        array.clear(fractalHighShadowLines)
        array.clear(fractalLowGlowLines)
        array.clear(fractalLowQuantumLines)
        array.clear(fractalLowShadowLines)
        array.clear(fractalHighLabels)
        array.clear(fractalLowLabels)        
        // Holonomy periods for labeling
        holonomy_periods = array.from(8, 13, 21, 34, 55)
        used_positions = array.new<float>()
        min_spacing = atr_confirmed * 0.2       
        // Draw fractal levels with enhanced effects
        for i = 0 to 4
            period = array.get(holonomy_periods, i)            
            // Dynamic transparency based on period
            base_alpha = 50 + i * 10
            glow_alpha = 70 + i * 6
            shadow_alpha = 85 + i * 3            
            // High fractals with triple-layer effect
            hi = array.get(fractalHighs, i)
            if not na(hi)
                // Shadow layer (darkest, widest)
                array.push(fractalHighShadowLines, line.new(bar_index - 5, hi, bar_index + 30, hi, color=color.new(phase_intense, shadow_alpha), width=5, style=line.style_solid))               
                // Main glow line
                array.push(fractalHighGlowLines, line.new(bar_index - 5, hi, bar_index + 30, hi, color=color.new(anomaly_strong, glow_alpha), width=3, style=line.style_solid))           
                // Quantum field line (dotted overlay)
                array.push(fractalHighQuantumLines, line.new(bar_index - 6, hi, bar_index + 31, hi, color=color.new(quantum_negative, base_alpha), width=1, style=line.style_dotted))               
                // Check label spacing
                can_place_label = true
                if array.size(used_positions) > 0
                    for j = 0 to array.size(used_positions) - 1
                        if math.abs(hi - array.get(used_positions, j)) < min_spacing
                            can_place_label := false
                            break                
                if can_place_label
                    // Calculate holonomy impact
                    price_distance = (hi - close) / atr_confirmed
                    holonomy_impact = signal_strength_confirmed - (price_distance * SCORE_AMPLIFIER / 10)
                    anomaly_strength = math.abs(holonomy_impact) / signal_threshold                    
                    // Enhanced label with gradient background
                    label_text = "H" + str.tostring(period) + ": " + str.tostring(hi, "#.##") + " Ï†: " + str.tostring(anomaly_strength, "#.##") + (anomaly_strength > 1.5 ? " âš¡" : anomaly_strength > 1.0 ? " â—" : " â—‹")                   
                    label_bg_color = anomaly_strength > 1.5 ? color.new(anomaly_strong, 75) : anomaly_strength > 1.0 ? color.new(holonomy_accent, 80) : color.new(visual_theme == "Void Resonance" ? #111111 : #1A1E2A, 85)                  
                    label_text_color = anomaly_strength > 1.0 ? anomaly_strong : holonomy_accent                   
                    new_label = label.new(bar_index + 31, hi, label_text, color=label_bg_color, textcolor=label_text_color, style=label.style_label_left, size=size.small)                   
                    array.push(fractalHighLabels, new_label)
                    array.push(used_positions, hi)           
            // Low fractals with triple-layer effect
            lo = array.get(fractalLows, i)
            if not na(lo)
                // Shadow layer (darkest, widest)
                array.push(fractalLowShadowLines, line.new(bar_index - 5, lo, bar_index + 30, lo, color=color.new(phase_intense, shadow_alpha), width=5, style=line.style_solid))                
                // Main glow line
                array.push(fractalLowGlowLines, line.new(bar_index - 5, lo, bar_index + 30, lo, color=color.new(quantum_positive, glow_alpha), width=3, style=line.style_solid))               
                // Quantum field line (dotted overlay)
                array.push(fractalLowQuantumLines, line.new(bar_index - 6, lo, bar_index + 31, lo, color=color.new(holonomy_primary, base_alpha), width=1, style=line.style_dotted))               
                // Check label spacing
                can_place_label = true
                if array.size(used_positions) > 0
                    for j = 0 to array.size(used_positions) - 1
                        if math.abs(lo - array.get(used_positions, j)) < min_spacing
                            can_place_label := false
                            break              
                if can_place_label
                    // Calculate holonomy impact
                    price_distance = (close - lo) / atr_confirmed
                    holonomy_impact = signal_strength_confirmed + (price_distance * SCORE_AMPLIFIER / 10)
                    anomaly_strength = math.abs(holonomy_impact) / signal_threshold                    
                    // Enhanced label with gradient background
                    label_text = "L" + str.tostring(period) + ": " + str.tostring(lo, "#.##") + " Ï†: " + str.tostring(anomaly_strength, "#.##") + (anomaly_strength > 1.5 ? " âš¡" : anomaly_strength > 1.0 ? " â—" : " â—‹")                 
                    label_bg_color = anomaly_strength > 1.5 ? color.new(quantum_positive, 75) : anomaly_strength > 1.0 ? color.new(holonomy_primary, 80) : color.new(visual_theme == "Void Resonance" ? #111111 : #1A1E2A, 85)                  
                    label_text_color = anomaly_strength > 1.0 ? quantum_positive : holonomy_primary                   
                    new_label = label.new(bar_index + 31, lo, label_text, color=label_bg_color, textcolor=label_text_color, style=label.style_label_left, size=size.small)                  
                    array.push(fractalLowLabels, new_label)
                    array.push(used_positions, lo)
// ========================================
// PHASE SPACE FLOW
// ========================================
phase_x = (close - ta.sma(close, 21)) / atr_confirmed
phase_y = (volume - ta.sma(volume, 21)) / ta.sma(volume, 21)
flow_strength = math.sqrt(phase_x * phase_x + phase_y * phase_y)
flow_angle = phase_x != 0 ? math.atan(phase_y / phase_x) : 0
flow_color = flow_strength > 2 ? color.new(phase_intense, 85) : flow_strength > 1 ? color.new(phase_normal, 90) : color.new(holonomy_secondary, 95)
bgcolor(show_phase_flow ? flow_color : na, title="Phase Space Flow")
phase_x_val = phase_x
phase_y_val = phase_y
// ========================================
// HOLONOMY PATH TRACERS
// ========================================
if show_holonomy_field
    for i = 1 to 10
        if i <= bar_index
            hist_signal = signal_strength_confirmed[i]
            path_y = close[i]
            path_color = hist_signal > 0 ? color.new(quantum_positive, 70 + i * 3) : color.new(quantum_negative, 70 + i * 3)
            label.new(bar_index - i, path_y, "Â·", color=path_color, textcolor=path_color, style=label.style_none, size=size.small)
// ============================================
// CORE CALCULATIONS (Add this before dashboard)
// ============================================
// Basic indicators
atr = ta.atr(14)
rsi = ta.rsi(close, 14)
sma20 = ta.sma(close, 20)  // Extract SMA calculation
ema50 = ta.ema(close, 50)
// Trend direction (fixed)
trend_direction = close > sma20 ? 1 : close < sma20 ? -1 : 0
// Holonomy Score calculation (0-1 range)
momentum = ta.mom(close, 10)
price_position = (close - ta.lowest(low, 50)) / (ta.highest(high, 50) - ta.lowest(low, 50))
holonomy_score = (rsi/100 + price_position) / 2
// Anomaly Level calculation (0-100 range)
bb_upper = ta.sma(close, 20) + 2 * ta.stdev(close, 20)
bb_lower = ta.sma(close, 20) - 2 * ta.stdev(close, 20)
bb_position = close > bb_upper ? 100 : close < bb_lower ? 100 : 0
volume_spike = volume > ta.sma(volume, 20) * 1.5 ? 50 : 0
anomaly_level = math.min(bb_position + volume_spike, 100)
// Quantum State calculation (-1, 0, 1)
bullish_conditions = close > sma20 and rsi > 50 and momentum > 0
bearish_conditions = close < sma20 and rsi < 50 and momentum < 0
quantum_state = bullish_conditions ? 1 : bearish_conditions ? -1 : 0
// Volatility
volatility = ta.stdev(close, 20) / sma20 * 100
// ============================================
// COLOR THEME DEFINITIONS
// ============================================
[theme_bg, theme_primary, theme_accent1, theme_accent2, theme_text] = switch visual_theme
    "Quantum Nebula" => [color.new(#0a0a0f, 95), color.new(#6b46c1, 0), color.new(#9333ea, 0), color.new(#c084fc, 0), color.new(#e9d5ff, 0)]
    "Ethereal Prism" => [color.new(#0f0a0f, 95), color.new(#f97316, 0), color.new(#eab308, 0), color.new(#10b981, 0), color.new(#fef3c7, 0)]
    "Dark Matter" => [color.new(#000000, 95), color.new(#ffffff, 0), color.new(#888888, 0), color.new(#444444, 0), color.new(#ffffff, 0)]
    "Cosmic Aurora" => [color.new(#001a1a, 95), color.new(#00ffcc, 0), color.new(#ff00ff, 0), color.new(#00ff00, 0), color.new(#e0ffff, 0)]
    "Void Resonance" => [color.new(#050505, 95), color.new(#ff00ff, 0), color.new(#00ffff, 0), color.new(#ffff00, 0), color.new(#ffffff, 0)]
    "Temporal Flux" => [color.new(#0a0a1a, 95), color.new(#4169e1, 0), color.new(#ff1493, 0), color.new(#00ced1, 0), color.new(#e6e6fa, 0)]
    "Astral Projection" => [color.new(#0d0d1a, 95), color.new(#9370db, 0), color.new(#ff69b4, 0), color.new(#87ceeb, 0), color.new(#f0e6ff, 0)]
    => [color.new(#0a0a0f, 95), color.new(#6b46c1, 0), color.new(#9333ea, 0), color.new(#c084fc, 0), color.new(#e9d5ff, 0)]
//==============================================================================
// ENHANCED DASHBOARD WITH PROFESSIONAL STYLING
//==============================================================================
var table dashboard = na
if show_dashboard and barstate.isconfirmed
    // Dashboard positioning and sizing
    dashboard_pos = dashboard_position_input == "Top Left" ? position.top_left : dashboard_position_input == "Top Right" ? position.top_right : dashboard_position_input == "Bottom Left" ? position.bottom_left : position.bottom_right
    cols = dashboard_size == "Large" ? 5 : 4
    rows = dashboard_size == "Large" ? 25 : dashboard_size == "Normal" ? 20 : 14
    // Clean up existing dashboard
    if not na(dashboard)
        table.delete(dashboard)   
    // Create new dashboard
    dashboard := table.new(dashboard_pos, cols, rows, border_width = 1, border_color = color.new(holonomy_accent, 50), bgcolor = color.new(#1e222d, 20))    
    // Color scheme
    dc_white = color.white
    dc_gray = #B2B5BE
    dc_green = #26A69A
    dc_red = #EF5350
    dc_gold = #FFD700
    dc_purple = holonomy_primary
    dc_aqua = holonomy_accent
    dc_orange = #FF8C00
    dc_cyan = #00FFFF
    bg_header = color.new(color.black, 30)
    bg_section = color.new(color.gray, 85)   
    // Text sizing
    header_size = dashboard_size == "Large" ? size.normal : size.small
    value_size = dashboard_size == "Large" ? size.normal : size.small
    label_size = dashboard_size == "Large" ? size.small : size.tiny   
    current_row = 0   
    // â•â•â• MAIN HEADER â•â•â•
    table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
    table.cell(dashboard, 0, current_row, "ğŸŒŒ Anomalous Holonomy Field Theory | " + syminfo.ticker, text_halign=text.align_center, text_color=dc_white, bgcolor=bg_header, text_size=header_size)
    current_row += 1
    // â•â•â• HOLONOMY FIELD SECTION â•â•â•
    table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
    table.cell(dashboard, 0, current_row, "â•â•â• âš¡ HOLONOMY FIELD STATUS â•â•â•", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
    current_row += 1   
    // Field Strength
    table.cell(dashboard, 0, current_row, "Field Strength", text_color=dc_gray, text_size=label_size)
    table.merge_cells(dashboard, 1, current_row, cols - 1, current_row)
    field_color = math.abs(signal_strength_confirmed) > signal_threshold ? (signal_strength_confirmed > 0 ? dc_green : dc_red) : dc_gray
    field_emoji = math.abs(signal_strength_confirmed) > signal_threshold * 1.5 ? "âš¡" : math.abs(signal_strength_confirmed) > signal_threshold ? "â—" : "â—‹"
    table.cell(dashboard, 1, current_row, field_emoji + " " + str.tostring(signal_strength_confirmed, "#.##"), text_halign=text.align_right, text_color=field_color, text_size=value_size)
    current_row += 1    
    // Signal Quality
    table.cell(dashboard, 0, current_row, "Quality", text_color=dc_gray, text_size=label_size)
    table.merge_cells(dashboard, 1, current_row, cols - 1, current_row)
    quality_emoji = signal_quality_rating == "ELITE" ? "ğŸŒŸ" : signal_quality_rating == "STRONG" ? "ğŸ’ª" : signal_quality_rating == "GOOD" ? "ğŸ‘" : "âš ï¸"
    quality_color = signal_quality_rating == "ELITE" ? dc_gold : signal_quality_rating == "STRONG" ? dc_green : signal_quality_rating == "GOOD" ? dc_aqua : dc_gray
    table.cell(dashboard, 1, current_row, quality_emoji + " " + signal_quality_rating, text_halign=text.align_right, text_color=quality_color, text_size=value_size)
    current_row += 1    
    // Threshold and Anomaly Level
    if dashboard_size != "Small"
        table.cell(dashboard, 0, current_row, "Threshold", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 1, current_row, str.tostring(signal_threshold, "#.##"), text_halign=text.align_right, text_color=dc_cyan, text_size=label_size)
        table.cell(dashboard, 2, current_row, "Anomaly", text_color=dc_gray, text_size=label_size)
        anomaly_color = anomaly_level > 70 ? dc_red : anomaly_level > 30 ? dc_orange : dc_green
        table.cell(dashboard, 3, current_row, str.tostring(anomaly_level, "#") + "%", text_halign=text.align_right, text_color=anomaly_color, text_size=label_size)
        current_row += 1   
    // â•â•â• QUANTUM STATE ANALYSIS â•â•â•
    table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
    table.cell(dashboard, 0, current_row, "â•â•â• ğŸ”® QUANTUM STATE ANALYSIS â•â•â•", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
    current_row += 1    
    // Quantum State with visual gauge
    quantum_gauge = quantum_state == 1 ? "ğŸŸ¢ğŸŸ¢ğŸŸ¢âšªâšª" : quantum_state == -1 ? "âšªâšªğŸ”´ğŸ”´ğŸ”´" : "âšªâšªğŸŸ¡âšªâšª"
    table.cell(dashboard, 0, current_row, "Quantum State", text_color=dc_gray, text_size=label_size)
    state_color = quantum_state == 1 ? dc_green : quantum_state == -1 ? dc_red : dc_orange
    state_text = quantum_state == 1 ? "â†‘ BULL" : quantum_state == -1 ? "â†“ BEAR" : "â—ˆ SUPER"
    table.cell(dashboard, 1, current_row, state_text, text_halign=text.align_right, text_color=state_color, text_size=value_size)   
    if dashboard_size == "Large"
        table.cell(dashboard, 2, current_row, "State", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 3, current_row, quantum_gauge, text_halign=text.align_right, text_color=state_color, text_size=label_size)
    else
        table.merge_cells(dashboard, 2, current_row, cols - 1, current_row)
        table.cell(dashboard, 2, current_row, quantum_gauge, text_halign=text.align_right, text_color=state_color, text_size=label_size)
    current_row += 1   
    // Trend Direction and Phase
    table.cell(dashboard, 0, current_row, "Trend", text_color=dc_gray, text_size=label_size)
    trend_text = trend_direction > 0 ? "ğŸ“ˆ BULL" : trend_direction < 0 ? "ğŸ“‰ BEAR" : "â¡ï¸ NEUTRAL"
    trend_color = trend_direction > 0 ? dc_green : trend_direction < 0 ? dc_red : dc_gray
    table.cell(dashboard, 1, current_row, trend_text, text_color=trend_color, text_size=label_size)   
    table.cell(dashboard, 2, current_row, "Phase", text_color=dc_gray, text_size=label_size)
    phase_text = flow_strength > 2 ? "ğŸŒªï¸ CHAOS" : flow_strength > 1 ? "âš¡ ACTIVE" : "ğŸ˜´ CALM"
    phase_color = flow_strength > 2 ? dc_red : flow_strength > 1 ? dc_gold : dc_gray
    table.cell(dashboard, 3, current_row, phase_text, text_color=phase_color, text_size=label_size)
    current_row += 1    
    // â•â•â• TRADING SIGNALS â•â•â•
    table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
    table.cell(dashboard, 0, current_row, "â•â•â• ğŸ¯ TRADING SIGNALS â•â•â•", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
    current_row += 1    
    // Long and Short Signals
    long_active = signal_strength_confirmed >= signal_threshold and can_trade
    short_active = signal_strength_confirmed <= -signal_threshold and can_trade    
    table.cell(dashboard, 0, current_row, "Long Signal", text_color=dc_gray, text_size=label_size)
    long_text = long_active ? "ğŸŸ¢ ACTIVE" : "âšª INACTIVE"
    table.cell(dashboard, 1, current_row, long_text, text_color=long_active ? dc_green : dc_gray, text_size=label_size)   
    table.cell(dashboard, 2, current_row, "Short Signal", text_color=dc_gray, text_size=label_size)
    short_text = short_active ? "ğŸ”´ ACTIVE" : "âšª INACTIVE"
    table.cell(dashboard, 3, current_row, short_text, text_color=short_active ? dc_red : dc_gray, text_size=label_size)
    current_row += 1    
    // Current Position Status
    table.cell(dashboard, 0, current_row, "Position", text_color=dc_gray, text_size=label_size)
    position_text = strategy.position_size > 0 ? "ğŸŸ¢ LONG" : strategy.position_size < 0 ? "ğŸ”´ SHORT" : "âšª NONE"
    position_color = strategy.position_size > 0 ? dc_green : strategy.position_size < 0 ? dc_red : dc_gray
    table.cell(dashboard, 1, current_row, position_text, text_color=position_color, text_size=value_size)    
    // Trade Count and Risk
    table.cell(dashboard, 2, current_row, "Daily Trades", text_color=dc_gray, text_size=label_size)
    trade_color = daily_trades > MAX_DAILY_TRADES * 0.8 ? dc_red : daily_trades > MAX_DAILY_TRADES * 0.5 ? dc_orange : dc_green
    table.cell(dashboard, 3, current_row, str.tostring(daily_trades) + "/" + str.tostring(int(max_trades_adjusted)), text_color=trade_color, text_size=label_size)
    current_row += 1   
    // â•â•â• PERFORMANCE METRICS â•â•â• (Normal and Large only)
    if dashboard_size != "Small"
        table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
        table.cell(dashboard, 0, current_row, "â•â•â• ğŸ† PERFORMANCE METRICS â•â•â•", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
        current_row += 1       
        // Win Rate and P&L
        win_rate_display = win_rate * 100
        win_rate_color = win_rate >= 0.6 ? dc_green : win_rate >= 0.45 ? dc_orange : dc_red
        win_rate_emoji = win_rate >= 0.6 ? "ğŸ”¥" : win_rate >= 0.45 ? "ğŸ‘" : "âš ï¸"       
        table.cell(dashboard, 0, current_row, "Win Rate", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 1, current_row, win_rate_emoji + str.tostring(win_rate_display, "#.#") + "%", text_halign=text.align_right, text_color=win_rate_color, text_size=label_size)        
        table.cell(dashboard, 2, current_row, "Daily P&L", text_color=dc_gray, text_size=label_size)
        pnl_emoji = daily_pnl > 0 ? "ğŸ’š" : daily_pnl < 0 ? "ğŸ”´" : "âšª"
        table.cell(dashboard, 3, current_row, pnl_emoji + str.tostring(daily_pnl, "#.##"), text_halign=text.align_right, text_color=daily_pnl > 0 ? dc_green : daily_pnl < 0 ? dc_red : dc_gray, text_size=label_size)
        current_row += 1       
        // Adaptive Risk and Learning
        if ENABLE_LEARNING
            table.cell(dashboard, 0, current_row, "Adapt Risk", text_color=dc_gray, text_size=label_size)
            risk_text = adaptive_risk_multiplier > 1.2 ? "ğŸš€ HIGH" : adaptive_risk_multiplier > 0.8 ? "ğŸ“Š NORM" : "ğŸ›¡ï¸ LOW"
            risk_color = adaptive_risk_multiplier > 1.2 ? dc_red : adaptive_risk_multiplier > 0.8 ? dc_aqua : dc_green
            table.cell(dashboard, 1, current_row, risk_text, text_color=risk_color, text_size=label_size)           
            table.cell(dashboard, 2, current_row, "Learning", text_color=dc_gray, text_size=label_size)
            table.cell(dashboard, 3, current_row, "âœ… ACTIVE", text_color=dc_purple, text_size=label_size)
            current_row += 1    
    // â•â•â• MARKET STRUCTURE â•â•â• (Large only)
    if dashboard_size == "Large"
        table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
        table.cell(dashboard, 0, current_row, "â•â•â• ğŸŒŒ MARKET STRUCTURE â•â•â•", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
        current_row += 1        
        // Volatility and Execution Mode
        vol_text = high_vol ? "ğŸ”¥ HIGH" : low_vol ? "ğŸ˜´ LOW" : "ğŸ“Š NORMAL"
        vol_color = high_vol ? dc_red : low_vol ? dc_green : dc_aqua        
        table.cell(dashboard, 0, current_row, "Volatility", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 1, current_row, vol_text, text_color=vol_color, text_size=label_size)       
        table.cell(dashboard, 2, current_row, "Mode", text_color=dc_gray, text_size=label_size)
        mode_color = EXECUTION_MODE == "Aggressive" ? dc_red : EXECUTION_MODE == "Conservative" ? dc_green : dc_aqua
        table.cell(dashboard, 3, current_row, EXECUTION_MODE, text_color=mode_color, text_size=label_size)
        current_row += 1       
        // Session and Market Regime
        session_text = trade_allowed ? "ğŸŸ¢ OPEN" : "ğŸ”´ CLOSED"
        session_color = trade_allowed ? dc_green : dc_red        
        table.cell(dashboard, 0, current_row, "Session", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 1, current_row, session_text, text_color=session_color, text_size=label_size)       
        table.cell(dashboard, 2, current_row, "Regime", text_color=dc_gray, text_size=label_size)
        regime_text = market_regime_bullish ? "ğŸ‚ BULL" : "ğŸ» BEAR"
        regime_color = market_regime_bullish ? dc_green : dc_red
        table.cell(dashboard, 3, current_row, regime_text, text_color=regime_color, text_size=label_size)
        current_row += 1
    // â•â•â• SETTINGS SUMMARY â•â•â• (Large only)
    if dashboard_size == "Large"
        table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
        table.cell(dashboard, 0, current_row, "â•â•â• âš™ï¸ ACTIVE SETTINGS â•â•â•", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
        current_row += 1        
        // Key Settings
        table.cell(dashboard, 0, current_row, "Sensitivity", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 1, current_row, str.tostring(SIGNAL_SENSITIVITY, "#.#"), text_color=dc_cyan, text_size=label_size)
        table.cell(dashboard, 2, current_row, "Base Risk", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 3, current_row, str.tostring(BASE_RISK * 100, "#.##") + "%", text_color=dc_cyan, text_size=label_size)
        current_row += 1        
        table.cell(dashboard, 0, current_row, "Theme", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 1, current_row, visual_theme, text_color=dc_purple, text_size=label_size)
        table.cell(dashboard, 2, current_row, "Timezone", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 3, current_row, session_timezone, text_color=dc_cyan, text_size=label_size)
        current_row += 1
// ========================================
// ANIMATED WATERMARK
// ========================================
var table watermark = table.new(position.bottom_center, 3, 1, bgcolor=color.new(color.black, 100), border_width=0)
var int anim_frame = 0
var float pulse_alpha = 90
if barstate.isconfirmed
    anim_frame += 1
    pulse_alpha := 80 + math.sin(anim_frame * 0.1) * 15
    wm_color = signal_strength_confirmed > signal_threshold ? color.new(quantum_positive, int(pulse_alpha)) : signal_strength_confirmed < -signal_threshold ? color.new(quantum_negative, int(pulse_alpha)) : color.new(holonomy_accent, int(pulse_alpha))
    left_symbol = anim_frame % 30 < 15 ? "âŸ¨" : "ã€Š"
    right_symbol = anim_frame % 30 < 15 ? "âŸ©" : "ã€‹"
    center_symbol = anim_frame % 20 < 10 ? "â—ˆ" : "â—†"
    table.cell(watermark, 0, 0, left_symbol, text_color=wm_color, text_size=size.normal)
    table.cell(watermark, 1, 0, center_symbol + " AHFT | Holonomy Field Theory " + center_symbol, text_color=wm_color, text_size=dashboard_size == "Large" ? size.normal : size.small)
    table.cell(watermark, 2, 0, right_symbol, text_color=wm_color, text_size=size.normal)
// ========================================
// SIGNAL PLOTS
// ========================================
plot(signal_strength_confirmed, "Holonomy Field Strength", color=signal_strength_confirmed > 0 ? quantum_positive : quantum_negative, linewidth=3)
plot(signal_strength_confirmed, "Field Glow 1", color=color.new(signal_strength_confirmed > 0 ? quantum_positive : quantum_negative, 50), linewidth=5, display=display.none)
plot(signal_threshold, "Upper Anomaly Threshold", color=color.new(holonomy_accent, 50), linewidth=2, style=plot.style_line)
plot(-signal_threshold, "Lower Anomaly Threshold", color=color.new(holonomy_accent, 50), linewidth=2, style=plot.style_line)
hline(0, "Equilibrium", color=color.new(#B8B8B8, 80), linestyle=hline.style_dotted)
plotshape(strong_long and can_trade, style=shape.triangleup, location=location.belowbar, color=quantum_positive, size=size.small, title="Quantum Entry")
plotshape(strong_short and can_trade, style=shape.triangledown, location=location.abovebar, color=quantum_negative, size=size.small, title="Anomaly Entry")


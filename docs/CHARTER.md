
=======
[문법헌장]
파인스크립트 제공시 다음의 문법 헌장은 꼭 지키기
 Pine Script v5 불변의 개발 헌장 (The Immutable Coding Constitution)
이 프로젝트는 아래의 헌장을 어떠한 경우에도 위반하지 않습니다. 모든 코드는 이 헌장에 따라 10번 이상 감사됩니다. 이 헌장은 단순한 가이드라인이 아닌, 컴파일러와 우리 자신을 속이지 않기 위한 강제 규정입니다.
제1장: 구조와 순서 (Structure & Order)
이 장은 코드의 예측 가능성과 유지보수성의 기반이다.
제0조 (파일의 시작 원칙 - The Genesis Principle)
가. 모든 .pine 스크립트 파일의 가장 첫 번째 줄, 첫 번째 문자는 반드시 //@version=5 컴파일러 지시어로 시작해야 한다.
나. 이 지시어 앞에는 어떠한 종류의 주석, 공백, 또는 코드도 허용되지 않는다.
다. 이 조항은 다른 모든 헌장 조항에 우선하는, 스크립트의 정체성을 정의하는 절대적인 최상위 황금률이다.




제1조 (엄격한 순서): 코드는 반드시 Inputs → Global Vars → Core Calcs → Functions → Execution 순서로 작성한다. 하위 블록이 상위 블록의 존재를 모르는 일은 없어야 한다.
제2조 (단일 선언): 모든 var 변수는 스크립트 상단의 전용 섹션에서 단 한 번만 선언한다. 스크립트 중간에서 var 키워드가 다시 나타나는 것은 금지된다.
제2장: 문법과 표현 (Syntax & Expression)
이 장은 Pine Script v5 컴파일러와의 완벽한 소통을 보장한다.
제3조 (블록 정의의 유일한 원칙: 들여쓰기):
Pine Script에서 코드 블록(if, for, while, 함수, switch의 case 등 모든 제어문의 본문)을 정의하는 유일하고 절대적인 방법은 새로운 줄과 4칸의 들여쓰기이다.
어떠한 경우에도 제어문 블록을 위해 중괄호 이는 컴파일 오류의 직접적인 원인이 되며, '개발 헌장'의 가장 중대한 위반으로 간주한다.






제4조 (명령어의 원자성): 코드 한 줄은 오직 하나의 명확한 작업(하나의 할당 또는 하나의 함수 호출)만을 수행해야 한다. 쉼표(,)를 사용하여 여러 명령을 한 줄에 연결하는 행위는 절대 금지한다.
제5조 (재할당의 명시성): 선언된 변수의 값을 변경할 때는 반드시 재할당 연산자 := 만을 사용한다. =는 오직 최초 선언 시에만 사용한다.


제6조 (참조의 무결성): 스크립트 내에서 변수를 참조할 때는, 반드시 이전에 선언된 이름과 단 하나의 오타도 없이 정확하게 일치해야 한다. 특히 그룹명과 같이 반복 사용될 가능성이 있는 변수는 복사/붙여넣기를 권장하여 인간의 실수를 원천 차단한다. 이는 'Undeclared Identifier' 오류를 예방하는 가장 근본적인 원칙이다.
가. 함수의 인자(parameter)를 참조할 때는, 반드시 Pine Script 공식 문서에 명시된 정확한 이름을 사용해야 한다. entry_id와 id처럼 유사하지만 다른 이름을 사용하는 것은 '참조의 무결성'을 위반하는 가장 중대한 오류 중 하나이다.


제3장: 함수와 스코프 (Function & Scope)
이 장은 코드의 모듈성과 안정성을 보장한다.
제7조 (스코프의 불변성): 함수 내에서는 절대로 전역 변수의 값을 직접 수정( 함수는 계산 결과를 return하고, 값의 할당은 반드시 함수를 호출한 전역 스코프에서 이루어져야 한다. 이는 함수의 예측 가능성을 보장하는 핵심 원칙이다.
제8조 (인자의 명시성): 함수는 필요한 모든 값을 **명시적인 인자(parameter)**로 전달받아야 한다. 암묵적으로 전역 변수를 참조하여 결과를 내는 '부작용(side effect)'을 일으켜서는 안 된다.
제8조의 2 (함수 선언의 전역성 원칙 - The Global Declaration Principle for Functions)
가. 모든 사용자 정의 함수( => 구문을 사용하는 함수)는 반드시 **전역 스코프(global scope)**에서만 선언되어야 한다.
나. 함수 선언은 if, for, switch 또는 다른 함수의 본문과 같은 어떠한 지역 블록(local block) 내부에서도 절대 허용되지 않는다. 이를 위반하는 것은 Syntax error at input '=>'의 직접적인 원인이 되며, 컴파일러와의 계약을 파기하는 중대한 위반이다.
다. 이 원칙은 '제1장: 구조와 순서'를 강화하며, 코드의 모든 '도구(tool)'는 그것이 사용되기 전에 최상위 레벨에 정의되어야 함을 보장한다.


제4장: 상태와 실행 (State & Execution)
이 장은 자동매매 로직의 무결성을 보장한다.
제9조 ( 여러 캔들에 걸쳐 값을 유지해야 하는 모든 변수(거래 상태, 드로잉 객체 ID 등)는 반드시 하여 그 값이 매 캔들마다 초기화되는 재앙을 막는다.
제10조 (리페인팅 원천 봉쇄): barstate.isconfirmed를 사용하여 확정된 봉에서만 진입을 결정하고, request.security 사용 시 lookahead=barmerge.lookahead_off를 명시하여 미래 데이터를 보지 않는다. 이는 백테스트의 신뢰도를 지키는 최소한의 의무이다.
제11조 (실시간 알람 동기화): 실시간 청산을 목표로 하는 모든 alert() 함수는 반드시 하여, strategy.close()와 동일한 틱에서 알람이 발생하도록 보장한다.
제12조 (전략 함수의 전역 스코프 원칙):
모든 거래 실행 함수( 어떠한 if, for, switch 블록 안에도 위치해서는 안 된다.
조건부 주문 실행은 오직  (예: strategy.close(..., when = close > ma))
조건부 주문 수량은 삼항 연산자( (예: strategy.entry(..., qty = long_entry_triggered ? size : 0))
이 조항은 다른 모든 문법 규칙에 우선하는, 전략 실행의 가장 중요한 황금률이다.

 제14조 (스코프의 연속성 원칙 - The Principle of Sequential Scoping)
가. 한 조건부 블록에서 계산된 변수는, 그 변수가 반드시 존재한다고 보장되지 않는 다른 독립된 블록에서 참조될 수 없다.
나. 특정 작업을 위해 필요한 모든 데이터(예: 포지션 사이즈 계산)는, 해당 작업을 촉발하는 동일한 논리적 흐름 안에서 생성되고 사용되어야 한다.




최종 기술 회고 및 미래 개발 교리: The AHFT Doctrine

문서 번호: AHFT-PM-9.1.0
작성일: 2025-07-06
수신: AHFT-GU 프로젝트 책임자 및 모든 개발팀원
발신: 기술 감사팀
주제: v6부터 v8까지의 개발 과정에서 얻은 교훈을 체계적으로 정리하고, 향후 모든 AHFT 개발에 적용될 불변의 원칙, 즉 **"AHFT 개발 교리(The AHFT Doctrine)"**를 수립함.

1. 서론: 실패의 기록에서 지혜의 지도로

우리가 걸어온 AHFT 개발의 여정은 단순히 코드를 작성하는 과정이 아니었습니다. 그것은 Pine Script™ 엔진의 깊은 내부 동작과 백테스팅의 함정을 이해하고, 이론과 현실의 간극을 메우기 위한 험난하지만 귀중한 탐험이었습니다. 수많은 실패와 디버깅, 그리고 귀하의 날카로운 통찰력이 없었다면 우리는 여전히 "신기루"와 같은 백테스트 결과에 안주하고 있었을 것입니다.

이 문서는 우리의 모든 시행착오를 미래의 자산으로 바꾸기 위해 작성되었습니다. 이는 단순한 회고가 아니라, 앞으로 우리가 걷게 될 모든 개발 과정의 **"지도"**이자 **"헌법"**이 될 것입니다.

2. 최초의 적: "신의 시점" Look-Ahead Bias의 본질

모든 문제의 시작은 Look-Ahead Bias, 즉 "미래를 엿보는 행위"였습니다. 백테스트 엔진은 바(bar)가 마감되기 전에 그 바의 최종 high, low 값을 미리 알 수 있습니다. 만약 우리의 코드가 이 미확정 정보를 사용하여 거래를 결정한다면, 이는 실제 시장에서는 불가능한 "신의 시점" 거래가 되어 비현실적인 수익률을 만들어냅니다. 우리의 모든 고통은 이 근본적인 적을 정복하기 위한 과정이었습니다.

3. 실패와 교훈의 연대기: v6부터 v8까지의 여정
Phase 1: v6.x - "순수의 시대"와 첫 번째 교훈

시도: strategy.exit()의 alert_message 파라미터를 사용하여 청산 알람을 보내려 했습니다.

문제:

침묵의 TSL: TSL(Trailing Stop Loss)에 의한 청산 시, 엔진의 동적인 가격 업데이트 메커니즘으로 인해 alert_message가 안정적으로 트리거되지 않았습니다.

정보의 부재: 기본 알람은 자동매매에 필수적인 SL/TP 가격, 수량 등의 정보를 담지 못했습니다.

얻은 교훈:

교리 제1조: 명령과 보고를 분리하라 (The Principle of Command-Report Separation).
strategy.* 함수는 브로커에게 "명령"을 내리는 역할에만 충실해야 하며, 모든 "보고"는 alert() 함수를 통해 우리가 직접, 완벽하게 통제해야 한다.

Phase 2: v7.x (가상) - "실시간성의 유혹"과 두 번째 교훈

시도: Exit Alert 누락 문제를 해결하기 위해, 주문 체결 즉시 스크립트를 재계산하는 **calc_on_order_fills=true**를 도입하고, TSL 로직에서 현재 바의 high, low를 참조했습니다.

문제:

"Look-Ahead Bias" 경고 발생: 백테스트 엔진이 스크립트가 미래 가격을 보고 거래한다고 공식적으로 경고했습니다.

비현실적인 수익률: 백테스트 결과가 극적으로 향상되었지만, 이는 실제 시장에서는 결코 재현 불가능한 "사기성 거래"의 결과였습니다.

"유령 청산" 현상: 차트에는 청산 마커가 보이지만, 실제 알람은 발생하지 않는 등 백테스트와 알람 시스템 간의 완전한 불일치가 발생했습니다.

얻은 교훈:

교리 제2조: 시간적 무결성을 존중하라 (The Principle of Temporal Integrity).
백테스트의 무결성은 실시간 반응성보다 우선한다. 모든 전략적 판단은 반드시 **과거의 확정된 데이터([1] 인덱스, barstate.isconfirmed)**에만 기반해야 한다. 현재 바의 미확정 데이터(high, low)를 참조하는 것은 금지된 과실이다.

Phase 3: v8.x - "정밀도를 향한 도전"과 마지막 교훈

시도: Look-Ahead Bias를 피하면서 정밀도를 높이기 위해 MTF Sentinel (request.security_lower_tf) 아키텍처를 도입했습니다. 이 과정에서 두 가지 중요한 실패를 겪었습니다.

실패 1 (v8.2 - "무방비 포지션"):

가설: strategy.exit 자체가 문제의 원인이니, 완전히 제거하고 LTF for 루프와 strategy.close만으로 청산하자.

결과: 진입 후 다음 틱까지 포지션이 SL/TP 없이 완전히 무방비 상태에 놓였습니다. 백테스트 엔진은 이 비표준적인 로직을 처리하지 못했고, 전략은 사실상 멈췄습니다.

교훈:

교리 제3조: 무중단 방어를 구축하라 (The Principle of Uninterrupted Protection).
모든 strategy.entry()는 즉시 기본적인 보호 주문(strategy.exit)을 동반해야 한다. 포지션은 단 한 틱이라도 보호 없이 시장에 노출되어서는 안 된다.

실패 2 (v8.3 - "두 명의 사령관"):

가설: strategy.exit로 기본 보호를 설정하고, 동시에 LTF for 루프로 정밀 청산을 시도하자.

결과: 기본 방어선(strategy.exit의 지정가 주문)과 특수 부대(for 루프의 시장가 주문)가 서로 경쟁하는 **명령 충돌(Race Condition)**이 발생했습니다. 이는 예측 불가능한 동작과 과도한 수수료를 유발했습니다.

교훈:

교리 제4조: 단일 지휘 체계를 확립하라 (The Principle of Unified Command).
두 개 이상의 독립적인 로직이 동일한 포지션을 동시에 청산하려 시도해서는 안 된다. 정밀 청산 로Cg은 기본 보호 주문을 대체하는 것이 아니라, 더 나은 시점에 **선제적으로 실행(Override)**하는 방식으로 작동해야 한다.

4. AHFT 미래 개발 교리 (The AHFT Development Doctrine)

우리의 모든 실패와 성공은 다음 5가지 불변의 원칙으로 귀결됩니다. 이는 향후 모든 AHFT 개발의 근간이 될 것입니다.

명령과 보고의 분리: 알람은 alert()로, 주문은 strategy.*로. alert_message는 사용하지 않는다.

시간적 무결성: 모든 계산은 확정된 과거 데이터([1], barstate.isconfirmed)에만 기반한다. 현재 바의 미확정 high, low 참조를 금지한다.

무중단 방어: 모든 진입은 즉시 strategy.exit을 통한 기본 보호 주문을 동반해야 한다.

단일 지휘 체계: 청산 명령은 단 하나의 논리적 흐름을 따라야 한다. 고급 로직은 기본 주문을 선제적으로 실행하는 방식으로 작동해야 한다.

현실 동기화의 원칙: 우리의 최종 목표는 **"백테스트와 실거래의 결과가 일치하는가?"**라는 질문에 "예"라고 답하는 것이다. 보기 좋은 백테스트보다 정직한 백테스트가 무한히 더 가치 있다.


5. 다음 단계: v9.0 "Sentient Core"를 향하여

이 교리들을 바탕으로, 우리는 이제 안정적으로 차세대 기능을 개발할 수 있습니다.

"정직한 TSL"의 구현: v8.4에서 우리는 barstate.isconfirmed와 high[1]을 사용하여 Look-Ahead가 없는 TSL을 구현할 것입니다. 이는 과거의 과장된 성과를 보여주지는 않겠지만, 100% 현실적인 결과를 보장할 것입니다.

지능의 추가: 이 안정적인 기반 위에, 우리는 Hurst 지수, OFPI, CMM, QSSI 등의 고급 개념을 "필터" 또는 "상황 판단 엔진"으로 추가하여, 거래의 "질"을 높이는 데 집중할 것입니다.

이 문서는 우리의 "실패의 역사"이자, 다시는 같은 실수를 반복하지 않겠다는 "약속"입니다. 모든 팀원은 이 교리를 숙지하고, 모든 코드 한 줄에 이 철학을 담아주시기 바랍니다.
=======


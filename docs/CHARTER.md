최종 기술 회고 및 미래 개발 교리: The AHFT Doctrine

문서 번호: AHFT-PM-9.1.0
작성일: 2025-07-06
수신: AHFT-GU 프로젝트 책임자 및 모든 개발팀원
발신: 기술 감사팀
주제: v6부터 v8까지의 개발 과정에서 얻은 교훈을 체계적으로 정리하고, 향후 모든 AHFT 개발에 적용될 불변의 원칙, 즉 **"AHFT 개발 교리(The AHFT Doctrine)"**를 수립함.

1. 서론: 실패의 기록에서 지혜의 지도로

우리가 걸어온 AHFT 개발의 여정은 단순히 코드를 작성하는 과정이 아니었습니다. 그것은 Pine Script™ 엔진의 깊은 내부 동작과 백테스팅의 함정을 이해하고, 이론과 현실의 간극을 메우기 위한 험난하지만 귀중한 탐험이었습니다. 수많은 실패와 디버깅, 그리고 귀하의 날카로운 통찰력이 없었다면 우리는 여전히 "신기루"와 같은 백테스트 결과에 안주하고 있었을 것입니다.

이 문서는 우리의 모든 시행착오를 미래의 자산으로 바꾸기 위해 작성되었습니다. 이는 단순한 회고가 아니라, 앞으로 우리가 걷게 될 모든 개발 과정의 **"지도"**이자 **"헌법"**이 될 것입니다.

2. 최초의 적: "신의 시점" Look-Ahead Bias의 본질

모든 문제의 시작은 Look-Ahead Bias, 즉 "미래를 엿보는 행위"였습니다. 백테스트 엔진은 바(bar)가 마감되기 전에 그 바의 최종 high, low 값을 미리 알 수 있습니다. 만약 우리의 코드가 이 미확정 정보를 사용하여 거래를 결정한다면, 이는 실제 시장에서는 불가능한 "신의 시점" 거래가 되어 비현실적인 수익률을 만들어냅니다. 우리의 모든 고통은 이 근본적인 적을 정복하기 위한 과정이었습니다.

3. 실패와 교훈의 연대기: v6부터 v8까지의 여정
Phase 1: v6.x - "순수의 시대"와 첫 번째 교훈

시도: strategy.exit()의 alert_message 파라미터를 사용하여 청산 알람을 보내려 했습니다.

문제:

침묵의 TSL: TSL(Trailing Stop Loss)에 의한 청산 시, 엔진의 동적인 가격 업데이트 메커니즘으로 인해 alert_message가 안정적으로 트리거되지 않았습니다.

정보의 부재: 기본 알람은 자동매매에 필수적인 SL/TP 가격, 수량 등의 정보를 담지 못했습니다.

얻은 교훈:

교리 제1조: 명령과 보고를 분리하라 (The Principle of Command-Report Separation).
strategy.* 함수는 브로커에게 "명령"을 내리는 역할에만 충실해야 하며, 모든 "보고"는 alert() 함수를 통해 우리가 직접, 완벽하게 통제해야 한다.

Phase 2: v7.x (가상) - "실시간성의 유혹"과 두 번째 교훈

시도: Exit Alert 누락 문제를 해결하기 위해, 주문 체결 즉시 스크립트를 재계산하는 **calc_on_order_fills=true**를 도입하고, TSL 로직에서 현재 바의 high, low를 참조했습니다.

문제:

"Look-Ahead Bias" 경고 발생: 백테스트 엔진이 스크립트가 미래 가격을 보고 거래한다고 공식적으로 경고했습니다.

비현실적인 수익률: 백테스트 결과가 극적으로 향상되었지만, 이는 실제 시장에서는 결코 재현 불가능한 "사기성 거래"의 결과였습니다.

"유령 청산" 현상: 차트에는 청산 마커가 보이지만, 실제 알람은 발생하지 않는 등 백테스트와 알람 시스템 간의 완전한 불일치가 발생했습니다.

얻은 교훈:

교리 제2조: 시간적 무결성을 존중하라 (The Principle of Temporal Integrity).
백테스트의 무결성은 실시간 반응성보다 우선한다. 모든 전략적 판단은 반드시 **과거의 확정된 데이터([1] 인덱스, barstate.isconfirmed)**에만 기반해야 한다. 현재 바의 미확정 데이터(high, low)를 참조하는 것은 금지된 과실이다.

Phase 3: v8.x - "정밀도를 향한 도전"과 마지막 교훈

시도: Look-Ahead Bias를 피하면서 정밀도를 높이기 위해 MTF Sentinel (request.security_lower_tf) 아키텍처를 도입했습니다. 이 과정에서 두 가지 중요한 실패를 겪었습니다.

실패 1 (v8.2 - "무방비 포지션"):

가설: strategy.exit 자체가 문제의 원인이니, 완전히 제거하고 LTF for 루프와 strategy.close만으로 청산하자.

결과: 진입 후 다음 틱까지 포지션이 SL/TP 없이 완전히 무방비 상태에 놓였습니다. 백테스트 엔진은 이 비표준적인 로직을 처리하지 못했고, 전략은 사실상 멈췄습니다.

교훈:

교리 제3조: 무중단 방어를 구축하라 (The Principle of Uninterrupted Protection).
모든 strategy.entry()는 즉시 기본적인 보호 주문(strategy.exit)을 동반해야 한다. 포지션은 단 한 틱이라도 보호 없이 시장에 노출되어서는 안 된다.

실패 2 (v8.3 - "두 명의 사령관"):

가설: strategy.exit로 기본 보호를 설정하고, 동시에 LTF for 루프로 정밀 청산을 시도하자.

결과: 기본 방어선(strategy.exit의 지정가 주문)과 특수 부대(for 루프의 시장가 주문)가 서로 경쟁하는 **명령 충돌(Race Condition)**이 발생했습니다. 이는 예측 불가능한 동작과 과도한 수수료를 유발했습니다.

교훈:

교리 제4조: 단일 지휘 체계를 확립하라 (The Principle of Unified Command).
두 개 이상의 독립적인 로직이 동일한 포지션을 동시에 청산하려 시도해서는 안 된다. 정밀 청산 로Cg은 기본 보호 주문을 대체하는 것이 아니라, 더 나은 시점에 **선제적으로 실행(Override)**하는 방식으로 작동해야 한다.

4. AHFT 미래 개발 교리 (The AHFT Development Doctrine)

우리의 모든 실패와 성공은 다음 5가지 불변의 원칙으로 귀결됩니다. 이는 향후 모든 AHFT 개발의 근간이 될 것입니다.

명령과 보고의 분리: 알람은 alert()로, 주문은 strategy.*로. alert_message는 사용하지 않는다.

시간적 무결성: 모든 계산은 확정된 과거 데이터([1], barstate.isconfirmed)에만 기반한다. 현재 바의 미확정 high, low 참조를 금지한다.

무중단 방어: 모든 진입은 즉시 strategy.exit을 통한 기본 보호 주문을 동반해야 한다.

단일 지휘 체계: 청산 명령은 단 하나의 논리적 흐름을 따라야 한다. 고급 로직은 기본 주문을 선제적으로 실행하는 방식으로 작동해야 한다.

현실 동기화의 원칙: 우리의 최종 목표는 **"백테스트와 실거래의 결과가 일치하는가?"**라는 질문에 "예"라고 답하는 것이다. 보기 좋은 백테스트보다 정직한 백테스트가 무한히 더 가치 있다.

5. 다음 단계: v9.0 "Sentient Core"를 향하여

이 교리들을 바탕으로, 우리는 이제 안정적으로 차세대 기능을 개발할 수 있습니다.

"정직한 TSL"의 구현: v8.4에서 우리는 barstate.isconfirmed와 high[1]을 사용하여 Look-Ahead가 없는 TSL을 구현할 것입니다. 이는 과거의 과장된 성과를 보여주지는 않겠지만, 100% 현실적인 결과를 보장할 것입니다.

지능의 추가: 이 안정적인 기반 위에, 우리는 Hurst 지수, OFPI, CMM, QSSI 등의 고급 개념을 "필터" 또는 "상황 판단 엔진"으로 추가하여, 거래의 "질"을 높이는 데 집중할 것입니다.

이 문서는 우리의 "실패의 역사"이자, 다시는 같은 실수를 반복하지 않겠다는 "약속"입니다. 모든 팀원은 이 교리를 숙지하고, 모든 코드 한 줄에 이 철학을 담아주시기 바랍니다.
